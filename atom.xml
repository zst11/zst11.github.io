<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-11-28T01:51:23.131Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mongodb-blog</title>
    <link href="http://example.com/2023/11/28/mongodb-blog/"/>
    <id>http://example.com/2023/11/28/mongodb-blog/</id>
    <published>2023-11-27T16:33:41.000Z</published>
    <updated>2023-11-28T01:51:23.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MongoDB学习"><a href="#MongoDB学习" class="headerlink" title="MongoDB学习"></a>MongoDB学习</h1><h2 id="1、MongoDB介绍"><a href="#1、MongoDB介绍" class="headerlink" title="1、MongoDB介绍"></a>1、MongoDB介绍</h2><h3 id="1-1-什么是mongodb"><a href="#1-1-什么是mongodb" class="headerlink" title="1.1 什么是mongodb"></a>1.1 什么是mongodb</h3><p>文档数据库（以json为数据模型），介于关系型和非关系型之间。</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/28/mongodb-blog/image-20231128003854345.png" alt="image-20231128003854345"></p><p>所以从此可以看出mongodb想要改变结构只需改变json，而关系型数据库需修改表结构。结构灵活</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/28/mongodb-blog/image-20231128003921486.png" alt="image-20231128003921486"></p><h3 id="1-2-MongoDB技术优势"><a href="#1-2-MongoDB技术优势" class="headerlink" title="1.2 MongoDB技术优势"></a>1.2 MongoDB技术优势</h3><p>json文档，灵活！！！处理海量数据有优势，高可用</p><p>可横向扩展</p><h3 id="1-3-使用场景"><a href="#1-3-使用场景" class="headerlink" title="1.3 使用场景"></a>1.3 使用场景</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/11/28/mongodb-blog/image-20231128004833427.png" alt="image-20231128004833427"></p><h2 id="2、快速开始"><a href="#2、快速开始" class="headerlink" title="2、快速开始"></a>2、快速开始</h2><h3 id="1-1、Linux安装mongodb"><a href="#1-1、Linux安装mongodb" class="headerlink" title="1.1、Linux安装mongodb"></a>1.1、Linux安装mongodb</h3><h3 id="1-2、mongodb启动"><a href="#1-2、mongodb启动" class="headerlink" title="1.2、mongodb启动"></a>1.2、mongodb启动</h3><p>命令启动</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先创建数据存放和日志存放地址</span></span><br><span class="line">[root@zst mongodb]# ls</span><br><span class="line">data  log  mongodb4.4.25  mongodb-linux-x86_64-rhel70-4.4.25.tgz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动命令 --fork表示后台启动</span></span><br><span class="line">[root@zst mongodb4.4.25]# bin/mongod --port=27017 --dbpath=/usr/local/mongodb/data --logpath=/usr/local/mongodb/log/mongodb.log --bind_ip=0.0.0.0 --fork</span><br><span class="line">about to fork child process, waiting until server is ready for connections.</span><br><span class="line">forked process: 16159</span><br><span class="line">child process started successfully, parent exiting</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入mongodb shell</span></span><br><span class="line">[root@zst mongodb4.4.25]# bin/mongo</span><br><span class="line">MongoDB shell version v4.4.25</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;gssapiServiceName=mongodb</span><br><span class="line">Implicit session: session &#123; &quot;id&quot; : UUID(&quot;df3bb765-b7ef-4489-b7d3-d553b5434a17&quot;) &#125;</span><br><span class="line">MongoDB server version: 4.4.25</span><br><span class="line">Welcome to the MongoDB shell.</span><br><span class="line">For interactive help, type &quot;help&quot;.</span><br><span class="line">For more comprehensive documentation, see</span><br><span class="line">https://docs.mongodb.com/</span><br><span class="line">Questions? Try the MongoDB Developer Community Forums</span><br><span class="line">https://community.mongodb.com</span><br><span class="line">---</span><br><span class="line">The server generated these startup warnings when booting: </span><br><span class="line">        2023-11-28T01:08:28.549+08:00: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine. See http://dochub.mongodb.org/core/prodnotes-filesystem</span><br><span class="line">        2023-11-28T01:08:29.437+08:00: Access control is not enabled for the database. Read and write access to data and configuration is unrestricted</span><br><span class="line">        2023-11-28T01:08:29.437+08:00: You are running this process as the root user, which is not recommended</span><br><span class="line">        2023-11-28T01:08:29.437+08:00: /sys/kernel/mm/transparent_hugepage/enabled is &#x27;always&#x27;. We suggest setting it to &#x27;never&#x27;</span><br><span class="line">        2023-11-28T01:08:29.437+08:00: /sys/kernel/mm/transparent_hugepage/defrag is &#x27;always&#x27;. We suggest setting it to &#x27;never&#x27;</span><br><span class="line">---</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">show dbs</span></span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">show collections</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">show tables</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出 mongodb</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">use admin</span></span><br><span class="line">switched to db admin</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">db.shutdownServer()</span></span><br><span class="line">server should be down...</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">exit</span></span></span><br><span class="line">bye</span><br><span class="line">&#123;&quot;t&quot;:&#123;&quot;$date&quot;:&quot;2023-11-27T17:11:45.416Z&quot;&#125;,&quot;s&quot;:&quot;I&quot;,  &quot;c&quot;:&quot;QUERY&quot;,    &quot;id&quot;:22791,   &quot;ctx&quot;:&quot;js&quot;,&quot;msg&quot;:&quot;Failed to end logical session&quot;,&quot;attr&quot;:&#123;&quot;lsid&quot;:&#123;&quot;id&quot;:&#123;&quot;$uuid&quot;:&quot;df3bb765-b7ef-4489-b7d3-d553b5434a17&quot;&#125;&#125;,&quot;error&quot;:&#123;&quot;code&quot;:9001,&quot;codeName&quot;:&quot;SocketException&quot;,&quot;errmsg&quot;:&quot;socket exception [CONNECT_ERROR] server [couldn&#x27;t connect to server 127.0.0.1:27017, connection attempt failed: SocketException: Error connecting to 127.0.0.1:27017 :: caused by :: Connection refused]&quot;&#125;&#125;&#125;</span><br><span class="line">[root@zst mongodb4.4.25]# </span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>配置文件启动</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置文件 mongod.conf</span></span><br><span class="line">systemLog:</span><br><span class="line">  destination: file #日志输出方式。file/syslog,如果是file，需指定path，默认是输出到标准输出流中</span><br><span class="line">  path: /usr/local/mongodb/log/mongod.log  #日志路径</span><br><span class="line">  logAppend: false #启动时，日志追加在已有日志文件内还是备份旧日志后，创建新文件记录日志, 默认false</span><br><span class="line"></span><br><span class="line">net:</span><br><span class="line">  port: 27017 #监听端口，默认27017</span><br><span class="line">  bindIp: 0.0.0.0 #绑定监听的ip，设置为127.0.0.1时，只会监听本机</span><br><span class="line">  maxIncomingConnections: 65536 #最大连接数，可接受的连接数还受限于操作系统配置的最大连接数</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">wireObjectCheck: <span class="literal">true</span> <span class="comment">#校验客户端的请求，防止错误的或无效BSON插入,多层文档嵌套的对象会有轻微性能影响,默认true</span></span></span><br><span class="line"></span><br><span class="line">processManagement:</span><br><span class="line">  fork: true  # 后台运行</span><br><span class="line"></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /usr/local/mongodb/data  # 数据库地址</span><br><span class="line">  journal:</span><br><span class="line">    enabled: true #启动journal,64位系统默认开启，32位默认关闭</span><br><span class="line"></span><br><span class="line">[root@zst mongodb4.4.25]# bin/mongod -f /usr/local/mongodb/mongod.conf </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭文件第二种方式，shell命令外部</span></span><br><span class="line"></span><br><span class="line">[root@zst mongodb4.4.25]# ps -ef | grep mongodb</span><br><span class="line">root      5037     1  4 09:40 ?        00:00:01 bin/mongod -f /usr/local/mongodb/mongod.conf</span><br><span class="line">root      5136  1375  0 09:40 pts/0    00:00:00 grep --color=auto mongodb</span><br><span class="line">[root@zst mongodb4.4.25]# bin/mongod -f /usr/local/mongodb/mongod.conf --shutdown</span><br><span class="line">&#123;&quot;t&quot;:&#123;&quot;$date&quot;:&quot;2023-11-28T01:47:37.138Z&quot;&#125;,&quot;s&quot;:&quot;I&quot;,  &quot;c&quot;:&quot;CONTROL&quot;,  &quot;id&quot;:20697,   &quot;ctx&quot;:&quot;main&quot;,&quot;msg&quot;:&quot;Renamed existing log file&quot;,&quot;attr&quot;:&#123;&quot;oldLogPath&quot;:&quot;/usr/local/mongodb/log/mongod.log&quot;,&quot;newLogPath&quot;:&quot;/usr/local/mongodb/log/mongod.log.2023-11-28T01-47-37&quot;&#125;&#125;</span><br><span class="line">killing process with pid: 5037</span><br><span class="line">[root@zst mongodb4.4.25]# ps -ef | grep mongodb</span><br><span class="line">root      5991  1375  0 09:49 pts/0    00:00:00 grep --color=auto mongodb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MongoDB学习&quot;&gt;&lt;a href=&quot;#MongoDB学习&quot; class=&quot;headerlink&quot; title=&quot;MongoDB学习&quot;&gt;&lt;/a&gt;MongoDB学习&lt;/h1&gt;&lt;h2 id=&quot;1、MongoDB介绍&quot;&gt;&lt;a href=&quot;#1、MongoDB介绍&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>linux_cmd</title>
    <link href="http://example.com/2023/11/24/linux-cmd/"/>
    <id>http://example.com/2023/11/24/linux-cmd/</id>
    <published>2023-11-24T08:13:06.000Z</published>
    <updated>2023-11-24T08:42:50.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@zst ~]# grep class linux-cmd.java  // grep，文件内检索指定内容</span><br><span class="line">public class EasyExcelTest &#123;</span><br><span class="line">    //                                 EasyExcel.read(file, Student.class,new StudentReadListener()).sheet().doRead();</span><br><span class="line">    //                                                                                                     EasyExcel.read(fileName, Student.class,listener).sheet().doRead();</span><br><span class="line">    //                                                                                                                                 //        EasyExcel.write(fileOutputStream, Student.class).sheet(&quot;学生信息&quot;).doWrite(getList());</span><br><span class="line">    //                                                                                                                                         ExcelWriter excelWriter = EasyExcel.write(fileOutputStream, Student.class).build();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>ctrl + z:退出但是进程没有切断</p><p>ctrl+ c：退出切切断</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@zst ~]# find ~ | grep &quot;test&quot;  # 管道符，前面输出作为后面输入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@zst ~]# ln -s 目标目录 源目录 # 软链接</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux命令&quot;&gt;&lt;a href=&quot;#Linux命令&quot; class=&quot;headerlink&quot; title=&quot;Linux命令&quot;&gt;&lt;/a&gt;Linux命令&lt;/h1&gt;&lt;div class=&quot;highlight-container&quot; data-rel=&quot;Shell&quot;&gt;&lt;fi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java-mianshi-blog</title>
    <link href="http://example.com/2023/11/16/java-mianshi-blog/"/>
    <id>http://example.com/2023/11/16/java-mianshi-blog/</id>
    <published>2023-11-16T03:50:00.000Z</published>
    <updated>2023-11-22T11:01:51.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><p><img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231116115158375.png" alt="image-20231116115158375"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231116120122940.png" alt="image-20231116120122940"></p><p>JDK9之后String底层使用byte【】，更加节约内存</p><p>2^10 &#x3D; 1kb,2^20 &#x3D; 1mb …..</p><p>string不可变是其引用不会变，并不是指向得值不会变</p><p>static 属性不会被序列化，因为其执行顺序是优先于对象存在得，序列化是针对于对象得</p><p>trainsient 关键字修饰得属性不会被序列化</p><p>list中得elementData之所以被trainsient关键字修饰，是因为其中有两个方法，writeObject和readObject</p><p>在序列化时会调用writeObject对size和其中得元素进行序列化</p><p>在反序列化时调用readObject对elementData进行恢复</p><p>之所以采用这种方式，是因为elementData中有缓存数组，序列化时浪费时间和空间，这样处理就只会处理真正有得值</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231116163545243.png" alt="image-20231116163545243"></p><p>过滤器：</p><p>init （）；doFilter（）；destory（）；</p><p>实现Filter接口；完成其中得doFilter方法，最后通过chain.doFilter(request,response)实现放行，可以在这之前进行判断，哪些不能放行</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231116163315933.png" alt="image-20231116163315933"></p><p>拦截器：</p><p>所有逻辑是再preHandler中处理得</p><p>实现HandlerInterceptor接口；</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231116163715553.png" alt="image-20231116163715553"></p><h1 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h1><p><img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231116163919055.png" alt="image-20231116163919055"></p><p>arraylist默认空实现和构造时传入0</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231116164432211.png" alt="image-20231116164432211"></p><p>在add时会先调用ensureCapacity，之所以默认得add时，会加10个null值，就在此</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231116183739526.png" alt="image-20231116183739526"></p><h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h2 id="ReentrantLock和Synchronized"><a href="#ReentrantLock和Synchronized" class="headerlink" title="ReentrantLock和Synchronized"></a>ReentrantLock和Synchronized</h2><p>后者通过标记就可实现而前者需要手动lock和unlock，用法如下</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>两者都是可重入锁，后者是非公平锁，前者可以设置为公平锁，通过在构造时传入true就可设置为公平锁</p><p>而其底层是在tryAcquire中进行了这样设置</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231116185905799.png" alt="image-20231116185905799"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231116185922889.png" alt="image-20231116185922889"></p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>使用场景：当每个线程都想为其自己设置时间格式时，这时就可以使用这个</p><p>使用其维护得变量在每个线程都会生成一个独立得副本，不会影响别的进程</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line"><span class="keyword">static</span> ThreadLocal&lt;String&gt; localVar = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="comment">//打印当前线程中本地内存中本地变量的值</span></span><br><span class="line">System.out.println(str + <span class="string">&quot; :&quot;</span> + localVar.get());</span><br><span class="line"><span class="comment">//清除本地内存中的本地变量</span></span><br><span class="line">localVar.remove();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//设置线程1中本地变量的值</span></span><br><span class="line">localVar.set(<span class="string">&quot;localVar1&quot;</span>);</span><br><span class="line"><span class="comment">//调用打印方法</span></span><br><span class="line">print(<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line"><span class="comment">//打印本地变量</span></span><br><span class="line">System.out.println(<span class="string">&quot;after remove : &quot;</span> + localVar.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//设置线程1中本地变量的值</span></span><br><span class="line">localVar.set(<span class="string">&quot;localVar2&quot;</span>);</span><br><span class="line"><span class="comment">//调用打印方法</span></span><br><span class="line">print(<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line"><span class="comment">//打印本地变量</span></span><br><span class="line">System.out.println(<span class="string">&quot;after remove : &quot;</span> + localVar.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>每个Thread都有一个ThreadLocalMap得内部类，其中键为ThreadLocal，值是具体得value</p><p>并且其继承了这个，所以键是弱引用，值是强引用；当使用完了之后，key被回收，就留下了value，会造成资源浪费，但是ThreadLocalMap在每次get（），set（），remove（）之后，都会对key为null得value进行回收，所以操作完记得remove一下</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231116191020566.png" alt="image-20231116191020566"></p><p>当ThreadLocal指向了同一个引用会导致隔离失败</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">ThreadLocal&lt;Map&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="comment">//在线程设置后，过段时间取name</span></span><br><span class="line"><span class="comment">//猜一猜结果？</span></span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;i am &quot;</span>+Thread.currentThread().getName());</span><br><span class="line">local.set(map); <span class="comment">//~~~</span></span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span></span><br><span class="line">+local.get().get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"><span class="comment">//do something...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span></span><br><span class="line">+local.get().get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="comment">//在线程中赋值name</span></span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;i am &quot;</span>+Thread.currentThread().getName());</span><br><span class="line">local.set(map); <span class="comment">// ~~~</span></span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>abstractQueueSynchronizer，抽象队列同步器，一套多线程访问共享资源得同步框架，ReentrantLock就是基于他</p><p>FIFO队列</p><p>AQS用一个 volatile int state 属性表示锁状态，1表示锁被持有，0表示未被持有，具体的维护由子类去维护，但是提供了修改该属性的三个方法： getState() ， setState(int newState) ，compareAndSetState(int expect, int update) ，其中CAS方法是核心。</p><p>使用者只需继承 AbstractQueuedSynchronizer 并重写指定的方法，在方法内完成对共享资源state 的获取和释放，至于具体线程等待队列的维护，AQS已经在顶层实现好了，在那些 final 的模板方法里。</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231116192520036.png" alt="image-20231116192520036"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231116192759496.png" alt="image-20231116192759496"></p><h1 id="Java-JVM"><a href="#Java-JVM" class="headerlink" title="Java-JVM"></a>Java-JVM</h1><p>hotspot vm</p><p>java -v xxxx.class</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231116212912664.png" alt="image-20231116212912664"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231116212934261.png" alt="image-20231116212934261"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231116213241859.png" alt="image-20231116213241859"></p><p>对象访问两种方式：1、句柄访问 2、直接地址</p><p>-Xms,-Xmx</p><p>GC:</p><p>1、引用计数法</p><p>2、可达性分析</p><p>​可选：虚拟机栈中引用得对象</p><p>​方法区中静态属性引用得变量</p><p>强引用，软引用（先进行一次回收，不够再回收），弱引用（GC时），虚引用</p><p>GC算法：</p><p>标记清除</p><p>标记整理：适用于老年代</p><p>标记复制：使用年轻代</p><p>回收器：cms，g1</p><p>调优器：gceasy</p><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>1、utf-8与utf-8mb4的区别，前者为后者的阉割版，也可以称为utf-8mb3，他最多支持3个字节去表示字符，而utf-8mb4是4个字节；</p><p>举个例子：如果字段类型是char(2)的话也就是固定两个字符串的个数，所以utf-8mb4会使用2 * 4 个字节去存储，而另一个使用2 * 3个字节来存储，所以这种情况下后者会比前者多占用空间。</p><p>2、数据是存储在磁盘的，如果没有所有，就需要很多次从磁盘读取数据的操作；而添加索引之后就不需要加载所有数据，而像b+树这种索引的数据结构读取磁盘次数一般都是2-4次。</p><p>3、redo log 保证事务持久性</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231119201518289.png" alt="image-20231119201518289"></p><p>undo log 保证事务原子性，一致性；记录相反操作</p><p>3、mvcc多版本并发控制，存储了一条数据不同版本；由三个隐藏字段、undo log、read view组成</p><p>由mvcc+锁保证事务隔离性，在读取时加上锁就保证了</p><p>4、<img lazyload src="/images/loading.svg" data-src="/2023/11/16/java-mianshi-blog/image-20231119204502599.png" alt="image-20231119204502599"></p><p>5、count（*），不会忽略null值，count（字段名）会</p><p>count（1）也是查询所有行，不会忽略</p><p>6、主键设置时并自增  primary key not null auto_increment</p><p>7、MD5的值是固定的，所有使用char存储更好</p><h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><p>不推荐使用注解方式自动注入，因为可能会导致空指针或者因为有多个实现类而找不到得原因</p><p>推荐使用基于构造器得方式注入</p><p>springMVC中controller是单例模式，所以多线程时会有安全问题，解决方法为不要写可变得状态量，如果写得话可以使用ThreadLocal作为线程变量</p><p>springMvc中拦截器是实现preHandel（）方法，其中三个方法，前置逻辑preHandle（）所有处理在这里完成，postHandle（）当返回视图时进行处理，afterHandle（）执行完控制器之后得一些资源清理，日志得记录。</p><p>分布式与微服务区别：前者是分散化，后者是服务专业化，以及精细分工</p><p>前者分散部署，后者分散能力</p><p>微服务设计原则：单一职责，服务自治，轻量级通信，接口明确原则</p><p>微服务间如何通信：1、rpc 2、消息队列</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础&quot;&gt;&lt;a href=&quot;#Java基础&quot; class=&quot;headerlink&quot; title=&quot;Java基础&quot;&gt;&lt;/a&gt;Java基础&lt;/h1&gt;&lt;p&gt;&lt;img lazyload src=&quot;/images/loading.svg&quot; data-src=&quot;/202</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringXxxx-blog</title>
    <link href="http://example.com/2023/11/13/SpringXxxx-blog/"/>
    <id>http://example.com/2023/11/13/SpringXxxx-blog/</id>
    <published>2023-11-13T15:35:01.000Z</published>
    <updated>2023-11-16T14:59:46.429Z</updated>
    
    <content type="html"><![CDATA[<p>SpringSecurity（安全）</p><p>RPC:远程过程调用，一种思想</p><p>通讯、序列化</p><p>Dubbo：</p><p>微服务四个核心问题</p><p>1、服务很多，客户该怎么访问</p><p>2、服务之间如何通信</p><p>3、如何治理</p><p>4、服务挂了怎么办</p><p>spring cloud ！ 生态</p><p>解决方案</p><p>1、spring cloud netflix  一站式解决方案</p><p>​api 网关 ；zuul组件</p><p>​feign 通信 —–httpclient</p><p>​eureka 服务注册</p><p>​熔断机制：Hystrix</p><p> 2、dubbo +zookeeper</p><p>​不完善需要借助别的</p><p>3、spring cloud Alibaba  一站式解决方案，更简单</p><p>万变不离其宗</p><p>1、api 网关</p><p>2、通信 http&#x2F;rpc</p><p>3、服务注册和发现</p><p>4、熔断机制</p><p>注册中心：记录微服务中每一个服务的IP端口…</p><p>配置中心：</p><p>服务网关：将请求路由到服务</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231114222842763.png" alt="image-20231114222842763"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231114223909596.png" alt="image-20231114223909596"></p><h1 id="SpringCLoud与Spring-Boot的关系"><a href="#SpringCLoud与Spring-Boot的关系" class="headerlink" title="SpringCLoud与Spring Boot的关系"></a>SpringCLoud与Spring Boot的关系</h1><ul><li>spring boot专注于单个个体的开发，就是常说的jar包与war包</li><li>springCloud关注全局的微服务协调治理框架，将spring boot开发的一个个单体的服务整合管理，为各个服务之间提供服务发现、路由。。。等等服务</li><li>sping boot可以离开cloud使用而cloud不能</li><li>boot专注于快速、方便的开发单体个体微服务，cloud关注全局的服务治理</li></ul><h1 id="springcloud与Dubbo（专注于远程调用）"><a href="#springcloud与Dubbo（专注于远程调用）" class="headerlink" title="springcloud与Dubbo（专注于远程调用）"></a>springcloud与Dubbo（专注于远程调用）</h1><p>springcloud 抛弃了dubbo的rpc通信，采用基于http的rest方式</p><p>dubbo需要组装各种各样的组件，而spingcloud一整套都是自己的生态</p><h1 id="springcloud能干嘛"><a href="#springcloud能干嘛" class="headerlink" title="springcloud能干嘛"></a>springcloud能干嘛</h1><p>分布式&#x2F;版本控制</p><p>服务注册与发现</p><p>路由</p><p>服务到服务的调用</p><p>负载均衡配置</p><p>断路器</p><p>分布式消息管理</p><h1 id="不同模块的调用"><a href="#不同模块的调用" class="headerlink" title="不同模块的调用"></a>不同模块的调用</h1><p>硬编码，后面通过注册中心</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231114225926554.png" alt="image-20231114225926554"></p><p>通过restTemplate来发送http请求到别的模块，可以发送不同的请求方式</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231114230134701.png" alt="image-20231114230134701"></p><h1 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h1><p>提供者与消费者</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231114230341528.png" alt="image-20231114230341528"></p><p>三个服务ABC</p><p>A-&gt;B-&gt;C</p><p>so？提供者与消费者？</p><p>相对而来看的！！！B可以是消费者也可以是提供者</p><h2 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h2><p>上面是服务端，下面是客户端</p><p>其中得user-service是相同得服务，端口不同，消费者拉取端口之后，做了负载均衡 </p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231114230838784.png" alt="image-20231114230838784"></p><p> 1、搭建EurekaServer</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231114231750347.png" alt="image-20231114231750347"></p><p>eureka自己也是服务，所以下面也配了其url</p><p>2、将别的服务注册到Eureka，不同得服务进行如下配置，该其名字</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231114232523961.png" alt="image-20231114232523961"></p><p>3、服务发现（拉取）</p><p>因为会有多个实例服务，在拉取时是用服务名称代替ip和端口做url，之后对服务列表做负载均衡；这里是轮询（RoundRobin）方式</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231114233123521.png" alt="image-20231114233123521"></p><h1 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h1><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231114233640333.png" alt="image-20231114233640333"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231114234255266.png" alt="image-20231114234255266"></p><p>里面得Dynamic….是用来缓存服务列表得，这样就不用每次都拉取，每隔30s进行一个拉取</p><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>标注得是其默认策略</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231114234453876.png" alt="image-20231114234453876"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231114234614596.png" alt="image-20231114234614596"></p><p>1、可以在配置类中实现一个IRule接口得方法，配置自己想要得轮询方式；全局得</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231114234736878.png" alt="image-20231114234736878"></p><p>2、添加新的配置；根据提供得微服务名字确定你想对哪个微服务设置</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231114234947438.png" alt="image-20231114234947438"></p><h3 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231114235413326.png" alt="image-20231114235413326"></p><h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><p>注册中心</p><p>相对于eureka功能更丰富</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115162509700.png" alt="image-20231115162509700"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115163035326.png" alt="image-20231115163035326"></p><h3 id="nacos多级存储模型"><a href="#nacos多级存储模型" class="headerlink" title="nacos多级存储模型"></a>nacos多级存储模型</h3><p>熔载：将多个实例分配在不同得地区集群中</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115165058346.png" alt="image-20231115165058346"></p><h3 id="nacosrule负载均衡"><a href="#nacosrule负载均衡" class="headerlink" title="nacosrule负载均衡"></a>nacosrule负载均衡</h3><p>不设置得话集群就没有用，还是使用默认得zoo…集群，所以需要修改</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115165401813.png" alt="image-20231115165401813"></p><p>这样访问是随机的</p><p>当我的服务在这几集群中进行访问，但集群中没有实例时，就会去别的集群中访问；有一个警告</p><h3 id="权重设置"><a href="#权重设置" class="headerlink" title="权重设置"></a>权重设置</h3><p>通过权重配置来访问，一般0-1</p><p>权重可以是0，这样就不会访问它</p><h3 id="环境隔离-namespace"><a href="#环境隔离-namespace" class="headerlink" title="环境隔离-namespace"></a>环境隔离-namespace</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115170447309.png" alt="image-20231115170447309"></p><p>命名空间中不同得组，不同组就放置了不同得服务，服务下面就是集群</p><p>可以将近似功能得系统放在同一组</p><p><strong>不是强制的</strong></p><p>在控制台中创建空间，会生成一个uuid，在配置文件中配置</p><p><strong>不同得namespace是不能访问得</strong></p><h1 id="Nacos与Eureka得对比"><a href="#Nacos与Eureka得对比" class="headerlink" title="Nacos与Eureka得对比"></a>Nacos与Eureka得对比</h1><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115171801248.png" alt="image-20231115171801248"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115171516082.png" alt="image-20231115171516082"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115171542976.png" alt="image-20231115171542976"></p><p>默认不配置就是临时得</p><p>临时：不健康了就会剔除</p><p>非临时：不会，只是做个标记，除非手动删除，实例活了就回来</p><p><strong>但，推荐临时，服务器压力就不会这么大</strong></p><h1 id="nacos配置管理"><a href="#nacos配置管理" class="headerlink" title="nacos配置管理"></a>nacos配置管理</h1><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>当服务增多，配置文件也就随之变多，使用配置管理，帮助我们更好的设置</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115183406253.png" alt="image-20231115183406253"></p><p>在nacos配置列表中进行配置，配置得是经常需要热更新的</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115183724450.png" alt="image-20231115183724450"></p><h2 id="拉取配置"><a href="#拉取配置" class="headerlink" title="拉取配置"></a>拉取配置</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115184041679.png" alt="image-20231115184041679"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115184110209.png" alt="image-20231115184110209"></p><p>这样properties中的相应配置就可以减去</p><p><strong>就可拿到nacos中配置了</strong></p><h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115184954711.png" alt="image-20231115184954711"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115185047573.png" alt="image-20231115185047573"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115185106390.png" alt="image-20231115185106390"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115185132232.png" alt="image-20231115185132232"></p><h2 id="多环境配置共享"><a href="#多环境配置共享" class="headerlink" title="多环境配置共享"></a>多环境配置共享</h2><p>环境有生产环境 dev</p><p>测试环境</p><p>开发环境</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115185415329.png" alt="image-20231115185415329"></p><p>不同的环境不能拿到别的配置文件，只能拿到公共的</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115185959114.png" alt="image-20231115185959114"></p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115190114422.png" alt="image-20231115190114422"></p><p>之后访问得就是nginx得端口了，会根据轮询给我代理到服务器，我们看到得是一个其实是三个，将配置文件中得nacos端口改为nginx得端口！！</p><h1 id="Feign-远程调用"><a href="#Feign-远程调用" class="headerlink" title="Feign 远程调用"></a>Feign 远程调用</h1><p>代替了restTemplate</p><p>声明式得http客户端</p><p>步骤：</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115215514228.png" alt="image-20231115215514228"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115215618025.png" alt="image-20231115215618025"></p><p>feign中还集成了ribbon负载均衡得依赖</p><h3 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115220149782.png" alt="image-20231115220149782"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115220240102.png" alt="image-20231115220240102"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115220411357.png" alt="image-20231115220411357"></p><p>这是放在启动类上得</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115220741436.png" alt="image-20231115220741436"></p><h3 id="实践分析"><a href="#实践分析" class="headerlink" title="实践分析"></a>实践分析</h3><p>1、</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115221401080.png" alt="image-20231115221401080"></p><p>2、</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115221643197.png" alt="image-20231115221643197"></p><p>两种方法有各自弊端：</p><p>第一种：当服务多，每个服务中都得写</p><p>第二种：当我们得服务只用到其中得一两种方法，却把整个jar包拿过来也不好</p><h3 id="实现抽取"><a href="#实现抽取" class="headerlink" title="实现抽取"></a>实现抽取</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115221923388.png" alt="image-20231115221923388"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115222338537.png" alt="image-20231115222338537"></p><h1 id="统一网关Gateway"><a href="#统一网关Gateway" class="headerlink" title="统一网关Gateway"></a>统一网关Gateway</h1><p>网关下得四个配置</p><ul><li>id ，路由标识，需唯一</li><li>uri：路由地址</li><li>predicate：断言，判断是否符合规则，由断言工厂来判断</li><li>filters：过滤器</li></ul><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115222740552.png" alt="image-20231115222740552"></p><p>实现网关得两种功能</p><ul><li>gateway：基于spring5提供得WebFlux响应式编程，性能好</li><li>zuul：基于Servlet实现，阻塞式编程</li></ul><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115223037566.png" alt="image-20231115223037566"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115223650964.png" alt="image-20231115223650964"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115223734568.png" alt="image-20231115223734568"></p><h2 id="路由断言工厂"><a href="#路由断言工厂" class="headerlink" title="路由断言工厂"></a>路由断言工厂</h2><p>读取用户配置得规则来决定是否可以通过</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115224014745.png" alt="image-20231115224014745"></p><p>使用方法如下：</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115224126288.png" alt="image-20231115224126288"></p><h2 id="路由过滤器GatewayFilter"><a href="#路由过滤器GatewayFilter" class="headerlink" title="路由过滤器GatewayFilter"></a>路由过滤器GatewayFilter</h2><p>一个过滤器链，不同得过滤器功能不同；</p><p>对路由得请求或响应做处理</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115225359650.png" alt="image-20231115225359650"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115225518822.png" alt="image-20231115225518822"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115225549723.png" alt="image-20231115225549723"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115225838075.png" alt="image-20231115225838075"></p><h2 id="全局过滤器-GlobalFilter"><a href="#全局过滤器-GlobalFilter" class="headerlink" title="全局过滤器 GlobalFilter"></a>全局过滤器 GlobalFilter</h2><p>对所有路由生效，其是自己定义得逻辑</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115230424024.png" alt="image-20231115230424024"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115231122927.png" alt="image-20231115231122927"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115231103102.png" alt="image-20231115231103102"></p><p>除了通过使用Order注解得到过滤器执行顺序，还可以实现一个Order接口，完成其中得方法</p><h2 id="过滤器执行顺序"><a href="#过滤器执行顺序" class="headerlink" title="过滤器执行顺序"></a>过滤器执行顺序</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115231524950.png" alt="image-20231115231524950"></p><p>默认过滤器和路由过滤器其都是gateway过滤器所以可以放在一个集合中</p><p>如下图，一个gatewayfilter适配器实现了gateway过滤器，其中维护了全局过滤器，当构造时传入一个全局过滤器可以适配成gateway过滤器，所以这三者是可以合并到一个过滤器链中得</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115231924538.png" alt="image-20231115231924538"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115232407864.png" alt="image-20231115232407864"></p><h2 id="跨域问题（CORS解决）"><a href="#跨域问题（CORS解决）" class="headerlink" title="跨域问题（CORS解决）"></a>跨域问题（CORS解决）</h2><p>浏览器去讯问服务器可不可以跨域 （CORS）</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115232944745.png" alt="image-20231115232944745"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231115232732900.png" alt="image-20231115232732900"></p><h1 id="服务雪崩-hystrix"><a href="#服务雪崩-hystrix" class="headerlink" title="服务雪崩 hystrix"></a>服务雪崩 hystrix</h1><p>分布式得链路中只要有一个服务宕机了，或者服务量大，其中得一个服务承受不住，就可能导致整个业务都瘫痪了</p><p>服务雪崩本质：线程没有及时回收</p><p>解决：</p><p>1、调整等待时间；不灵活</p><p>2、在上游中知道下游得状态</p><p>3、找备胎</p><p>可以容忍服务挂掉</p><h2 id="hystrix-熔断器"><a href="#hystrix-熔断器" class="headerlink" title="hystrix 熔断器"></a>hystrix 熔断器</h2><p>默认关闭</p><p>当另一个服务挂了时，就走这里</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/13/SpringXxxx-blog/image-20231116221016507.png" alt="image-20231116221016507"></p><p>服务熔断：当某一个服务挂了之后，通过hystrix得故障监控，向调用方返回一个备选响应，而不是长时间得等待，或者抛出异常，这样就可以将线程回收。</p><p>服务降级：当业务量大时，牺牲掉一些不是很重要得服务，来保证重要服务得进行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SpringSecurity（安全）&lt;/p&gt;
&lt;p&gt;RPC:远程过程调用，一种思想&lt;/p&gt;
&lt;p&gt;通讯、序列化&lt;/p&gt;
&lt;p&gt;Dubbo：&lt;/p&gt;
&lt;p&gt;微服务四个核心问题&lt;/p&gt;
&lt;p&gt;1、服务很多，客户该怎么访问&lt;/p&gt;
&lt;p&gt;2、服务之间如何通信&lt;/p&gt;
&lt;p&gt;3、如</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>rabbitmq-blog</title>
    <link href="http://example.com/2023/11/12/rabbitmq-blog/"/>
    <id>http://example.com/2023/11/12/rabbitmq-blog/</id>
    <published>2023-11-12T11:39:30.000Z</published>
    <updated>2023-11-19T16:00:40.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ学习"><a href="#RabbitMQ学习" class="headerlink" title="RabbitMQ学习"></a>RabbitMQ学习</h1><h2 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h2><p>message queue：消息队列</p><p>优势</p><ul><li>应用解耦 （容错，可维护）：将消息发送给中间件，不同的系统从中间件拿消息</li><li>异步提速（提速）</li></ul><p><img lazyload src="/images/loading.svg" data-src="/2023/11/12/rabbitmq-blog/image-20231112194201597.png" alt="image-20231112194201597"></p><ul><li>削峰填谷（增加系统稳定性）</li></ul><p><img lazyload src="/images/loading.svg" data-src="/2023/11/12/rabbitmq-blog/image-20231112194233284.png" alt="image-20231112194233284"></p><p>上面就是削峰</p><p>而填谷就是之后我们的系统在不断从MQ中处理信息就是填谷</p><p>劣势：</p><p>系统可用性降低</p><p>系统复杂度提高</p><p>一致性问题</p><h2 id="RabbitMQ（Erlang语言）"><a href="#RabbitMQ（Erlang语言）" class="headerlink" title="RabbitMQ（Erlang语言）"></a>RabbitMQ（Erlang语言）</h2><p>基于此AMQP（高级消息队列协议）：应用层协议，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息。</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/12/rabbitmq-blog/image-20231112194301949.png" alt="image-20231112194301949"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/12/rabbitmq-blog/image-20231112194327257.png" alt="image-20231112194327257"></p><p>RabbitMQ提供了6种简单模式，后面细看</p><p>JMS：是API的规范接口，类似于JDBC，但RabbitMQ并没有遵循此。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a class="link" href="https://blog.csdn.net/qq_45173404/article/details/116429302">RabbitMQ超详细安装教程（Linux）_rabbitmq安装-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>注意本机有一个默认账号guest，但只能本机localhost使用，远程登录不能使用！！！</p><h2 id="简单模式-hello-world"><a href="#简单模式-hello-world" class="headerlink" title="简单模式 hello world"></a>简单模式 hello world</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/11/12/rabbitmq-blog/image-20231112194353916.png" alt="image-20231112194353916"></p><p>生产者</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、创建连接工厂</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、设置参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、创建连接connection</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、创建channel</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、创建队列queue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、发送消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7、释放资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为是简单模式所以不需要exchange交换机，所以直接默认null</span></span><br></pre></td></tr></table></figure></div><p>消费者</p><pre><code>    // 1、创建连接工厂    // 2、设置参数    // 3、创建连接connection    // 4、创建channel    // 5、创建队列queue    // 6、接收消息    // 7、不用释放资源</code></pre><h2 id="工作队列-Work-Queues"><a href="#工作队列-Work-Queues" class="headerlink" title="工作队列 Work Queues"></a>工作队列 Work Queues</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/11/12/rabbitmq-blog/image-20231112194414974.png" alt="image-20231112194414974"></p><p>当工作比较重时可以有多个消费者</p><h2 id="Pub-Sub-发布订阅"><a href="#Pub-Sub-发布订阅" class="headerlink" title="Pub&#x2F;Sub 发布订阅"></a>Pub&#x2F;Sub 发布订阅</h2><blockquote><p>Fanout：广播，所有队列</p></blockquote><p><img lazyload src="/images/loading.svg" data-src="/2023/11/12/rabbitmq-blog/image-20231112194438011.png" alt="image-20231112194438011"></p><p>x:Exchange交换机（只负责转发消息），接收生产者发的消息，根据不同的Exchange类型交给不同的队列。</p><p>类型如下：</p><ul><li>Fanout：广播，所有队列</li><li>Direct：定向，交给指定routing key的队列</li><li>Topic：通配，交给符合routing pattern（路由模式）的队列</li><li>Headers：参数匹配，用得少</li></ul><p>和work queues的区别就是前者是多个消费者监听一条队列，后者多个消费者监听多个队列</p><h2 id="Routing-路由模式"><a href="#Routing-路由模式" class="headerlink" title="Routing 路由模式"></a>Routing 路由模式</h2><blockquote><p>Direct：定向，交给指定routing key的队列</p></blockquote><p><img lazyload src="/images/loading.svg" data-src="/2023/11/12/rabbitmq-blog/image-20231112194502785.png" alt="image-20231112194502785"></p><h2 id="Topic-通配符模式"><a href="#Topic-通配符模式" class="headerlink" title="Topic 通配符模式"></a>Topic 通配符模式</h2><blockquote><p>Topic：通配，交给符合routing pattern（路由模式）的队列</p></blockquote><p><img lazyload src="/images/loading.svg" data-src="/2023/11/12/rabbitmq-blog/image-20231112194516579.png" alt="image-20231112194516579"></p><p>其中：</p><p>#：代表0个或多个单词</p><p>*：代表1个单词</p><p>更加灵活</p><h2 id="使用spring-boot整合rabbitmq"><a href="#使用spring-boot整合rabbitmq" class="headerlink" title="使用spring boot整合rabbitmq"></a>使用spring boot整合rabbitmq</h2><p>生产者：</p><ul><li>创建spring boot工程</li><li>编写配置文件</li><li>编写配置类<ul><li>exchange创建</li><li>队列创建</li><li>绑定队列与exchange</li></ul></li><li>直接注入RabbitTemplate来完成消息发送</li></ul><p>消费者：</p><ul><li>创建spring boot工程</li><li>配置文件</li><li>编写监听类</li></ul><h2 id="消息可靠性投递"><a href="#消息可靠性投递" class="headerlink" title="消息可靠性投递"></a>消息可靠性投递</h2><p>消息的投递过程</p><p>producer—》rabbitmq broker—-》exchange—–》queue—-》consumer</p><h3 id="confirm-确认模式"><a href="#confirm-确认模式" class="headerlink" title="confirm 确认模式"></a>confirm 确认模式</h3><blockquote><p>生产者到exchange</p></blockquote><p>1、事务机制：在一条消息发送之后将发送端阻塞，等待rabbitmq的回应，之后才能继续发送下一条消息，性能差</p><p>2、确认机制：消息成功发送到交换机之后，rabbitmq就会发送一条ack给生产者，没有成功到达就会发送一条nack消息，提示失败；在生产端会提供一个回调方法，当服务端收到了一条或者多条消息后，生产者就会回调这个方法，根据具体方法对消息进行后续处理，如重新发送，记录日志等。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    rabbitmq:   </span><br><span class="line">        ##开启 confirm 确认机制</span><br><span class="line">        publisher-confirms: <span class="literal">true</span></span><br></pre></td></tr></table></figure></div><h3 id="路由不可达"><a href="#路由不可达" class="headerlink" title="路由不可达"></a>路由不可达</h3><blockquote><p>exchange到queue</p></blockquote><p>1、Return消息机制：提供一个回调函数ReturnCallback，当消息从exchange到queue失败就会回调这个方法</p><p>2、备份交换机：当没有匹配到queue时，就会将信息发送到对应交换机的queue</p><h3 id="消费者手动消息确认"><a href="#消费者手动消息确认" class="headerlink" title="消费者手动消息确认"></a>消费者手动消息确认</h3><blockquote><p>消费者收到消息但还没处理MQ就宕机了，导致消息丢失，因为默认采用自动ack，一旦收到消息就会告诉mq 已经处理好了，将其改为手动，只有当消费者处理完才回复</p></blockquote><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>当rabbitmq服务器突然异常导致重启，消息将会丢失，mq提供了持久化，将内存中的数据持久化到硬盘中</p><p>1、queue持久化</p><p>2、交换机持久化</p><p>3、消息设置持久化</p><h3 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h3><p>将queue镜像到集群其他结点上</p><h2 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h2><p>当rabbitmq中的积压了大量的消息之后，队列里的消息会大量涌入消费端，可能导致消费端崩溃，这时候需对消费端限流</p><p>Spring RabbitMQ提供了prefetch可以设置单个请求处理的消息条数，当消息达到设置的条数时就会阻塞，知道消息ack</p><blockquote><div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##在单个请求中处理的消息个数，unack的最大数量</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.prefetch</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure></div></blockquote><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>消费失败的消息存放的队列</p><p>失败原因：</p><ul><li>消息被拒绝并且没有重新入队</li><li>超时未消费</li><li>达到队列最大长度</li></ul><p>当普通队列中有死信的时候，rmq会自动将信息重新发布设置到死信交换机，之后被路由到死信队列。</p><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>当消息发送以后不想让消费者立刻拿到，等待特定时间后，消费者才能拿到</p><h2 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h2><p>两个原因：1、生产时消息重复；2、消费时消息重复</p><p>生产者发送消息给MQ，MQ确认的时候出现网络波动，生产者没有收到确认，然后又在发送了一条重复的消息</p><p>消费者消费成功后给MQack，出现了网络波动，MQ没有收到ack，之后MQ又给了消费者一条之前的消息，导致消费重复</p><p>解决办法：发送消息时让每个消息携带一个全局唯一的id，在进行消费先判断id；</p><p>1、消费者根据id去redis中查询</p><p>2、如果不存在，则正常消费，消费完写入redis</p><p>3、如果存在则说明被消费过了，直接丢弃</p><h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p>存活时间</p><p>创建指定队列得ttl，从消息入队列时开始计算，超过消息就会被移除</p><h2 id="消费者拿到消息两种方式"><a href="#消费者拿到消息两种方式" class="headerlink" title="消费者拿到消息两种方式"></a>消费者拿到消息两种方式</h2><p>推</p><p>拉</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RabbitMQ学习&quot;&gt;&lt;a href=&quot;#RabbitMQ学习&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ学习&quot;&gt;&lt;/a&gt;RabbitMQ学习&lt;/h1&gt;&lt;h2 id=&quot;MQ&quot;&gt;&lt;a href=&quot;#MQ&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mybatis-blog</title>
    <link href="http://example.com/2023/11/12/mybatis-blog/"/>
    <id>http://example.com/2023/11/12/mybatis-blog/</id>
    <published>2023-11-12T11:36:51.000Z</published>
    <updated>2023-11-12T15:30:32.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="1、JDBC编程的步骤"><a href="#1、JDBC编程的步骤" class="headerlink" title="1、JDBC编程的步骤"></a>1、JDBC编程的步骤</h2><ul><li>驱动注册 Class.forName(“com.mysql.cj.jdbc.Driver”)</li><li>建立JDBC与数据库的连接  Connection conn &#x3D; DriverManager.getConnection(“jdbc:mysql:&#x2F;&#x2F;ip:端口&#x2F;数据库名”，username，password)</li><li>创建Statement对象或者PrepareStatement <ul><li>Statement st &#x3D; conn.createStatement();</li></ul></li><li>执行sql，获取结果集</li><li>处理结果集<ul><li>next获取下一个位置是否有值</li></ul></li><li>释放资源</li></ul><h2 id="2、浅谈MyBatis"><a href="#2、浅谈MyBatis" class="headerlink" title="2、浅谈MyBatis"></a>2、浅谈MyBatis</h2><ul><li>是一个半ORM（对象关系映射）框架</li><li>通过内部封装jdbc操作，开发人员只需重点关注sql语句编写</li><li>通过xml或者注解方式将sql对象进行自动获取</li></ul><h2 id="3、优点与缺点以及和Hibernate有哪些不同"><a href="#3、优点与缺点以及和Hibernate有哪些不同" class="headerlink" title="3、优点与缺点以及和Hibernate有哪些不同"></a>3、优点与缺点以及和Hibernate有哪些不同</h2><p>优点：</p><ul><li>基于sql编程，相对灵活，不会对应用或者现有的数据现有的设计有影响，sql在xml中编写，降低程序耦合，且提供了动态sql语句的编写，且可重复使用</li><li>与jdbc相比，减少50%以上的代码，消除了大量冗余的代码</li><li>很好的与各种数据库兼容</li><li>mybatis和是spring有很好的集成</li><li>提供了映射标签，支持对象与数据库字段映射</li></ul><p>缺点：</p><ul><li>sql语句的编写工作量较大，尤其是字段多的情况，关联表情况困难</li><li>对数据库依赖大，不能随便更换数据库</li></ul><p>和hibernate的区别</p><p>hibernate是全ORM框架，不需要编写sql语句，通过配置直接完成结果映射</p><p>hibernate与数据库无关，方便移植</p><h2 id="4、-和-的区别"><a href="#4、-和-的区别" class="headerlink" title="4、#{} 和 ${}的区别"></a>4、#{} 和 ${}的区别</h2><p>#{}是通过预编译，使用的位置使用？占位，${}是通过拼接方式会有sql注入的风险</p><h2 id="5、jdbc问题分析，编写mybatis框架思路？"><a href="#5、jdbc问题分析，编写mybatis框架思路？" class="headerlink" title="5、jdbc问题分析，编写mybatis框架思路？"></a>5、jdbc问题分析，编写mybatis框架思路？</h2><p>问题分析：</p><ul><li>数据库信息是硬编码，修改的话需要修改代码</li><li>繁琐的配置与释放资源</li></ul><p>解决思路：</p><ul><li>通过配置文件，反射和dom4j解析完成对象创建以及数据存储</li><li>连接池</li></ul><p>思路分析：</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/12/mybatis-blog/image-20231112203111220.png" alt="image-20231112203111220"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/12/mybatis-blog/image-20231112203125136.png" alt="image-20231112203125136"></p><h2 id="6、当实体类中的属性名和表中的字段名不一致，如何处理？"><a href="#6、当实体类中的属性名和表中的字段名不一致，如何处理？" class="headerlink" title="6、当实体类中的属性名和表中的字段名不一致，如何处理？"></a>6、当实体类中的属性名和表中的字段名不一致，如何处理？</h2><ul><li>将表中的字段在查询时通过 as 起别名</li><li>通过resultmap映射</li><li>通过配置文件开启驼峰命令</li></ul><h2 id="7、mybatis中的动态sql使用到了哪些标签"><a href="#7、mybatis中的动态sql使用到了哪些标签" class="headerlink" title="7、mybatis中的动态sql使用到了哪些标签"></a>7、mybatis中的动态sql使用到了哪些标签</h2><p>1、if</p><p>2、where</p><p>3、trim：和where相同，只是其是去掉尾部多余的部分，且还可以根据其中的属性进行设置</p><p>4、choose when ：和if else-if类似</p><p>5、foreach</p><p>6、set</p><h2 id="8、实现一对一的方式有几种"><a href="#8、实现一对一的方式有几种" class="headerlink" title="8、实现一对一的方式有几种"></a>8、实现一对一的方式有几种</h2><ul><li>嵌套结果：多表操作</li><li>嵌套查询：分开的单表查询</li></ul><h2 id="9、mybatis是否支持延迟加载"><a href="#9、mybatis是否支持延迟加载" class="headerlink" title="9、mybatis是否支持延迟加载"></a>9、mybatis是否支持延迟加载</h2><p>是支持延迟加载的，延迟加载的时候是指在查找的时候只加载其基本属性，而其关联数据暂不加载</p><p>当我们输出或者调用的时候，延迟加载就失效了，还是会查出全部的信息</p><p>通过配置一个lazy….的配置文件</p><ul><li>提高性能，如果关联关系太多，反而会导致性能下降</li><li>在外部数据被修改会导致数据不一致</li></ul><h2 id="10、缓存机制"><a href="#10、缓存机制" class="headerlink" title="10、缓存机制"></a>10、缓存机制</h2><p>一级缓存：程序运行期间，可能一次数据库会话中，会执行多次相同的sql语句，mybatis提供了一级缓存优化方案，将数据保存在内存中（缓存中），提高性能</p><p> 多个不同的会话没有影响</p><p>二级缓存：针对于不同的mapper，多个不同的sqlsession对象共享数据，开启二级缓存，并配置标签<catch>或者配置注解</catch></p><p>一级或二级缓存在遇到增删改的时候会清理缓存</p><p>三级缓存：针对于第三方（redis）</p><h2 id="11、在mapper中如何传递多个参数"><a href="#11、在mapper中如何传递多个参数" class="headerlink" title="11、在mapper中如何传递多个参数"></a>11、在mapper中如何传递多个参数</h2><p>1、方法参数名直接对应xml中的获取内容参数名</p><p>2、按照索引方式，从0开始</p><p>3、使用param代替参数，但是写法应为param1，param2….</p><p>4、使用@Param注解标识参数名字，就可在xml中使用这个名字</p><h2 id="12、如何分页"><a href="#12、如何分页" class="headerlink" title="12、如何分页"></a>12、如何分页</h2><p>1、使用RowBounds对象进行分页</p><p>2、通过物理分页，结合sql的limit进行分页</p><h2 id="13、mybatis中的设计模式"><a href="#13、mybatis中的设计模式" class="headerlink" title="13、mybatis中的设计模式"></a>13、mybatis中的设计模式</h2><p>1、建造者模式：在mybatis环境初始化过程中，SqlSessionFactoryBuilder会调用XMLConfigBuilder读取config文件信息以及所有的mapper文件信息，构建mybatis核心对象SqlSessionFactory，然后通过该对象构成对应的sqlSession对象</p><p>2、工厂模式</p><p>3、单例模式</p><p>​ErrorContext和LogFactory（提供mybatis使用的日志工厂）使用</p><p>4、代理模式</p><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mybatis&quot;&gt;&lt;a href=&quot;#Mybatis&quot; class=&quot;headerlink&quot; title=&quot;Mybatis&quot;&gt;&lt;/a&gt;Mybatis&lt;/h1&gt;&lt;h2 id=&quot;1、JDBC编程的步骤&quot;&gt;&lt;a href=&quot;#1、JDBC编程的步骤&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>design-blog</title>
    <link href="http://example.com/2023/11/07/design-blog/"/>
    <id>http://example.com/2023/11/07/design-blog/</id>
    <published>2023-11-07T08:33:14.000Z</published>
    <updated>2023-11-16T12:28:36.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>总的来说设计模式分为三大类</p><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote><p>在JVM中，该对象只有一个实例存在</p><p>优点：</p><ul><li>某些创建频繁，对于一些大型的对象这是一笔很大的开销</li><li>省去new，减轻了GC的压力</li><li>有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。</li></ul></blockquote><p>1、枚举实现(非常简单！！！不要想复杂)</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是单例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样一个枚举就实现了单例模式</span></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        System.out.println(s1==s2); <span class="comment">// true</span></span><br><span class="line">        <span class="comment">// 调用其中方法</span></span><br><span class="line">        s1.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>2、双重检索模式</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 私有构造方法，防止被实例化 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 静态工程方法，创建实例 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(instance)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>剩下的懒汉、饿汉就不写了</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>首先有这些条件</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个共同接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Send</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有两个实现类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailSender</span> <span class="keyword">implements</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Send</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;this is mailsender!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsSender</span> <span class="keyword">implements</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Send</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;this is sms sender!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>1、普通工厂模式：建立一个工厂类，对实现了同一个接口的类进行创建</p><p><img lazyload src="/images/loading.svg" data-src="/design-blog/image-20231108190514036.png" alt="image-20231108190514036"></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendFactory</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Sender <span class="title function_">produce</span><span class="params">(String type)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;mail&quot;</span>.equals(type)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MailSender</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;sms&quot;</span>.equals(type)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SmsSender</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;请输入正确的类型!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryTest</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">SendFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendFactory</span>();</span><br><span class="line"><span class="type">Sender</span> <span class="variable">sender</span> <span class="operator">=</span> factory.produce(<span class="string">&quot;sms&quot;</span>);</span><br><span class="line">sender.Send();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>2、多个工厂方法模式</p><p><img lazyload src="/images/loading.svg" data-src="/design-blog/image-20231108190824254.png" alt="image-20231108190824254"></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendFactory</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Sender <span class="title function_">produceMail</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MailSender</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Sender <span class="title function_">produceSms</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SmsSender</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryTest</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">SendFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendFactory</span>();</span><br><span class="line"><span class="type">Sender</span> <span class="variable">sender</span> <span class="operator">=</span> factory.produceMail();</span><br><span class="line">sender.Send();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>3、静态工厂模式：就是将其中的方法都变为静态方法，这样就不用进行new了</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>工厂模式的问题就是如果有新的工厂需要创建，就需要对原有的代码进行改造，破坏了闭包原则，所以将工厂类抽成一个接口，增加新的工厂的时候实现接口就行了</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/07/design-blog/image-20231108191300599.png" alt="image-20231108191300599"></p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><blockquote><p>b站it老齐讲的不错</p></blockquote><p>当一个类中属性很多时，需要的构造函数也很多，创建起来就不是很方便；</p><p>这时候我们在其中抽象出一个静态的内部类，将所有属性放入到其中，</p><p>原本的这个类构造函数设为private，静态内部类中设置所有属性的set方法，返回值为这个静态内部类（return this），这样就可以一直使用.set</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/07/design-blog/image-20231108195203397.png" alt="image-20231108195203397"></p><p>静态内部类中一个build方法，返回类型为原本的类</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/07/design-blog/image-20231108195337911.png" alt="image-20231108195337911"></p><p>返回值如下</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/07/design-blog/image-20231108195443828.png" alt="image-20231108195443828"></p><p>最终的测试类就可以这样写</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/07/design-blog/image-20231108195551831.png" alt="image-20231108195551831"></p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>该模式的思想就是将一个对象作为原型，对其进行复制克隆产生一个和元对象类似的新对象；所以就是使用clone方法；</p><p>浅克隆：基本类型变量都会重新创建，引用类型变量还是指向了原来的对象</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个类实现Cloneable方法，Cloneable中没有什么方法，这里clone是本地方法（native）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"><span class="type">Prototype</span> <span class="variable">proto</span> <span class="operator">=</span> (Prototype) <span class="built_in">super</span>.clone();</span><br><span class="line"><span class="keyword">return</span> proto;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>深克隆：全是重新创建的；</p><p>实现方法，两种实现方式：1、在重写clone方法中对引用类型进行再一次clone；2、不实现Cloneable方法，通过实现Serializable序列化，之后对需要克隆的引用类型进行一个序列化流输入与输出</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Student stu;</span><br><span class="line"></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">tea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>, stu);</span><br><span class="line">        <span class="comment">//使用重写的的clone方法</span></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teaClone</span> <span class="operator">=</span> (Teacher) tea.clone();</span><br><span class="line">​</span><br><span class="line">        <span class="comment">/*clone之后改变原对象的数据*/</span></span><br><span class="line">        <span class="comment">//改变stu的数据</span></span><br><span class="line">        stu.name=<span class="string">&quot;李四改&quot;</span>;</span><br><span class="line">        <span class="comment">//改变tea的数据</span></span><br><span class="line">        tea.name=<span class="string">&quot;张三改&quot;</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">//结果被克隆的数据的内部类的stu数据没受到了影响,说明重写的clone方法,实现的是深克隆,tea的对象类型属性stu是指不同对象</span></span><br><span class="line">        System.out.println(teaClone);</span><br><span class="line">        System.out.println(tea);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">//改写clone方法</span></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">tea</span> <span class="operator">=</span> (Teacher) <span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">//获取属性对象,再clone一次,让后设置到被克隆的对象中,返回</span></span><br><span class="line">        tea.stu = ((Student) tea.stu.clone());</span><br><span class="line">        <span class="keyword">return</span> tea;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">int</span> age, Student stu)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.stu = stu;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Student stu;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">tea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>, stu);</span><br><span class="line">        <span class="comment">//内存数组输出流</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="comment">//序列化流</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bao);</span><br><span class="line">        <span class="comment">//将数据tea写入序列化流中,随后会被传递到内存数组输出流中,将对象序列化为byte[]类型的数据</span></span><br><span class="line">        oos.writeObject(tea);</span><br><span class="line">        <span class="comment">//从内存数组输出流中获取到tea的byte[]类型的数据,传入内存数组输入流</span></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bao.toByteArray());</span><br><span class="line">        <span class="comment">//将内存数组输入流传给反序列化流,这样也实现了byte[]类型的数据的传递</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bai);</span><br><span class="line">        <span class="comment">//使用readObject,从反序列化流中读取数据,将byte[]类型的数据反序列化成Teacher对象</span></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teaClone</span> <span class="operator">=</span> (Teacher) ois.readObject();</span><br><span class="line">        <span class="comment">//改变stu的数据</span></span><br><span class="line">        stu.name = <span class="string">&quot;李四改&quot;</span>;</span><br><span class="line">        <span class="comment">//改变tea的数据</span></span><br><span class="line">        tea.name = <span class="string">&quot;张三该&quot;</span>;</span><br><span class="line">        <span class="comment">//结果被克隆的数据的内部类的stu数据没有受到了影响,说明重写后的clone方法,实现了深克隆</span></span><br><span class="line">        System.out.println(teaClone);</span><br><span class="line">        System.out.println(tea);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">int</span> age, Student stu)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.stu = stu;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><blockquote><p>提供间接对目标对象的访问方式，通过代理对象访问目标对象，从而在目标对象现有功能上增加额外的功能补充，实现扩展目标对象的功能</p></blockquote><p>现在来分析以下主题接口，目标对象，代理对象都是什么</p><p>主题接口：就是我们想要实现的接口</p><p>目标对象：对主题接口的实现</p><p>代理对象：也是对主题接口的实现，但是其中还维护了目标对象，这样我们就可以实现对功能的增强</p><p><img lazyload src="/images/loading.svg" data-src="/design-blog/image-20231107184224310.png" alt="image-20231107184224310"></p><p><strong>有代理的情况</strong></p><p><img lazyload src="/images/loading.svg" data-src="/design-blog/image-20231107184256041.png" alt="image-20231107184256041"></p><p><strong>代码实现</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公共接口singer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Singer</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Singer</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;目标对象进行歌曲演唱&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Singer</span> &#123;</span><br><span class="line"><span class="comment">//代理对象中，需要持有真正的目标对象的引用</span></span><br><span class="line"><span class="comment">//其目的是在完成辅助工作之后，使用目标对象来完成真正的核心工作</span></span><br><span class="line"><span class="keyword">private</span> Singer target;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Proxy</span><span class="params">(Singer target)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//完成各种各种工作</span></span><br><span class="line">System.out.println(<span class="string">&quot;安排时间&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;联系场地&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;安全保障&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;合同签订&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;费用结算&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"><span class="comment">//使用目标对象来完成核心工作</span></span><br><span class="line"><span class="built_in">this</span>.target.sing();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>从中可以看出代理对目标类实现了功能的增强！！！</p><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>以前通过手动创建代理类，实现对目标对象的增强就是静态代理</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理则是在程序运行期间，采用字节码技术，动态生成的一个代理对象，从而实现目标对象中方法的增强。</p><blockquote><p>反射！！！</p></blockquote><h5 id="JDK动态代理（共同实现接口）"><a href="#JDK动态代理（共同实现接口）" class="headerlink" title="JDK动态代理（共同实现接口）"></a>JDK动态代理（共同实现接口）</h5><p>JDK动态代理主要是借助 java.lang.reflect.Proxy 生成代理对象</p><p><img lazyload src="/images/loading.svg" data-src="/design-blog/image-20231107184729068.png" alt="image-20231107184729068"></p><p><strong>代码实现</strong></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* proxy,将来动态生成的代理类对象</span></span><br><span class="line"><span class="comment">* method，将来需要代理的目标对象中的方法</span></span><br><span class="line"><span class="comment">* args，将来调用目标对象方法时所传入的参数列表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[]args)</span></span><br><span class="line"><span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中的lambda表达式实现的是InvocationHandler接口，它只有一个方法invoke(Object proxy, Method method, Object[]</span></span><br><span class="line"><span class="comment">// args)，所以此处使用lambda</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tests</span> &#123;</span><br><span class="line">    <span class="comment">// 直接new，交给Spring的容器得到的接口是不对的,BookServiceImpl2是一个实现了BookService接口的类</span></span><br><span class="line">    <span class="type">BookServiceImpl2</span> <span class="variable">impl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookServiceImpl2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 生成一个impl2的动态代理类对象</span></span><br><span class="line">        <span class="comment">// 1、类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> impl2.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 2、主题接口，要求是传一个接口的数组，意味着不一定只实现一个接口</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = impl2.getClass().getInterfaces();</span><br><span class="line">        System.out.println(Arrays.toString(interfaces));</span><br><span class="line">        <span class="comment">// 3、方法增强处理器</span></span><br><span class="line">        <span class="comment">// 使用Proxy的静态方法来产生动态代理对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">impl2Proxy</span> <span class="operator">=</span> Proxy.newProxyInstance(classLoader, interfaces,</span><br><span class="line">                (proxy, method, args) -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 处理逻辑写在这：主要是对目标类的同名方法增强</span></span><br><span class="line">                    <span class="comment">// proxy : 代理类对象</span></span><br><span class="line">                    <span class="comment">// method：目标类中被代理的方法</span></span><br><span class="line">                    <span class="comment">// args：方法的参数</span></span><br><span class="line">                    <span class="comment">// 输出方法的名字</span></span><br><span class="line">                    System.out.println(method.getName());</span><br><span class="line">                    <span class="comment">// 执行方法</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(impl2,args);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> invoke;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 调用代理类</span></span><br><span class="line">        System.out.println(impl2Proxy.getClass());</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) impl2Proxy;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bookService.saveBook(<span class="keyword">new</span> <span class="title class_">Book</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h5 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h5><p>和目标类继承同一个类或者是目标类的子类！</p><p>如果父类中的方法是private 或者 final修饰就不行</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testCglib</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// CGLIB中产生代理对象的核心类型</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置父类型（目标类的类型）</span></span><br><span class="line">        enhancer.setSuperclass(BookServiceImpl.class);</span><br><span class="line"></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> o 代理类对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method 被代理的方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> objects 传参</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> methodProxy 方法代理对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> 被代理方法的返回值</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;开启事务&quot;</span>+method.getName());</span><br><span class="line">                <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">                System.out.println(<span class="string">&quot;日志管理&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两种方式获得代理对象</span></span><br><span class="line"><span class="comment">//        Class aClass = enhancer.createClass();</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;第一种：&quot;+aClass);</span></span><br><span class="line">        <span class="type">BookServiceImpl</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookServiceImpl) enhancer.create();</span><br><span class="line">        System.out.println(<span class="string">&quot;第二种：&quot;</span>+bookService.getClass());</span><br><span class="line">        <span class="comment">// 调用被代理对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bookService.saveBook(<span class="keyword">new</span> <span class="title class_">Book</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>当我们需要使用一个类，但是他提供的接口又与我们系统的接口不兼容，这时候适配器模式就应运而生了，其就是为了解决两个接口或者类之间不兼容的问题！</p><p>那怎么解决呢？</p><p>这就要引出IT世界的一句俗语了，没有什么是问题是加一层解决不了的，如果有，那就再加一层！！</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogFactory</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String tag,String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要和目标接口进行匹配的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NbLogger</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">d</span><span class="params">(<span class="type">int</span> priority, String message, Object ... obj)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NbLoggerImp</span> <span class="keyword">implements</span> <span class="title class_">NbLogger</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">d</span><span class="params">(<span class="type">int</span> priority, String message, Object... obj)</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;牛逼logger记录:%s&quot;</span>,message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以发现两者是不兼容的</span></span><br><span class="line"><span class="comment">// 构建适配器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAdapter</span> <span class="keyword">implements</span> <span class="title class_">LogFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> NbLogger nbLogger;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogAdapter</span><span class="params">(NbLogger nbLogger)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nbLogger = nbLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String tag, String message)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(nbLogger);</span><br><span class="line">        nbLogger.d(<span class="number">1</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>和代理模式差不多</p><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>和spring boot 的ioc差不多</p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>顾名思义，</p><p>就是我们通过一个桥去到达哪里，而使用到代码中就是使用桥接类，就可以去调用别的类</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/07/design-blog/image-20231110155619502.png" alt="image-20231110155619502"></p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义方法接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Sourceable</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SourceSub1</span> <span class="keyword">implements</span> <span class="title class_">Sourceable</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;this is the first sub!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SourceSub2</span> <span class="keyword">implements</span> <span class="title class_">Sourceable</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;this is the second sub!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义桥类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Bridge</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Sourceable source;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">source.method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Sourceable <span class="title function_">getSource</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSource</span><span class="params">(Sourceable source)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.source = source;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承桥类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBridge</span> <span class="keyword">extends</span> <span class="title class_">Bridge</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">getSource().method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BridgeTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Bridge</span> <span class="variable">bridge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBridge</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用第一个对象*/</span></span><br><span class="line"><span class="type">Sourceable</span> <span class="variable">source1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SourceSub1</span>();</span><br><span class="line">bridge.setSource(source1);</span><br><span class="line">bridge.method();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用第二个对象*/</span></span><br><span class="line"><span class="type">Sourceable</span> <span class="variable">source2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SourceSub2</span>();</span><br><span class="line">bridge.setSource(source2);</span><br><span class="line">bridge.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>一个抽象类中有一个主方法，再定义1…n个抽象方法或者实际方法，定义一个类用来实现抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用</p><p>​</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCalculator</span> &#123;</span><br><span class="line"><span class="comment">/*主方法，实现对本类其它方法的调用*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String exp,String opt)</span>&#123;</span><br><span class="line"><span class="type">int</span> array[] = split(exp,opt);</span><br><span class="line"><span class="keyword">return</span> calculate(array[<span class="number">0</span>],array[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*被子类重写的方法*/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate1</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] split(String exp,String opt)&#123;</span><br><span class="line">String array[] = exp.split(opt);</span><br><span class="line"><span class="type">int</span> arrayInt[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">arrayInt[<span class="number">0</span>] = Integer.parseInt(array[<span class="number">0</span>]);</span><br><span class="line">arrayInt[<span class="number">1</span>] = Integer.parseInt(array[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> arrayInt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Plus</span> <span class="keyword">extends</span> <span class="title class_">AbstractCalculator</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate1</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyTest</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="string">&quot;8+8&quot;</span>;</span><br><span class="line"><span class="type">AbstractCalculator</span> <span class="variable">cal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Plus</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> cal.calculate(exp, <span class="string">&quot;\\+&quot;</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>迭代子模式</p><p>和迭代器一样</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">iterator</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    Object <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIterator</span> implents iterator&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">positon</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    List&lt;Object&gt; elements;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyIterator</span><span class="params">(List&lt;Object&gt; elements)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.elements = elements;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> positon &lt; elements.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">n</span> <span class="operator">=</span> elements.get(potion++);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Aggregate</span>&#123;</span><br><span class="line">    MyIterator <span class="title function_">creatIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCollections</span> implents Aggregate&#123;</span><br><span class="line">    List&lt;Object&gt; elements;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCollections</span><span class="params">(List&lt;Object&gt; elements)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.elements = elements;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MyIterator <span class="title function_">creatorIterator</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyIterator</span>(<span class="built_in">this</span>.elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCollection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCollections</span>();</span><br><span class="line">        collection.add(<span class="number">1</span>);</span><br><span class="line">        collection.add(<span class="number">2</span>);</span><br><span class="line">        collection.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> collection.createIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h1&gt;&lt;p&gt;总的来说设计模式分为三大类&lt;/p&gt;
&lt;p&gt;创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>redis-blog</title>
    <link href="http://example.com/2023/11/06/redis-blog/"/>
    <id>http://example.com/2023/11/06/redis-blog/</id>
    <published>2023-11-06T14:41:08.000Z</published>
    <updated>2023-11-22T04:10:32.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis学习"><a href="#Redis学习" class="headerlink" title="Redis学习"></a>Redis学习</h1><blockquote><p>敬畏之心可以使人进步！</p></blockquote><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>远程字典服务；key-value数据库；持久化，主从复制；周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件</p></blockquote><p>效率高、可用于高速缓存；发布订阅信息；地图信息分析。。。。</p><p>redis是一个开源的，内存中的数据结构存储系统，可以用作数据库、缓存、中间件MQ</p><h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><p><strong>下载地址：</strong><a class="link" href="https://github.com/dmajkic/redis/downloads">https://github.com/dmajkic/redis/downloads <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>默认端口：6379</p><p>先启动服务端</p><p>再启动客户端</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231106234501382.png" alt="image-20231106234501382"></p><p><strong>推荐使用Linux</strong></p><h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><p>1、官网下载稳定版</p><p>2、解压</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231106235954877.png" alt="image-20231106235954877"></p><p>3、安装基础环境</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@zst redis-stable]# yum install gcc-c++</span><br><span class="line"></span><br><span class="line">[root@zst redis-stable]# make</span><br><span class="line"></span><br><span class="line"> [root@zst redis-stable]# make install</span><br></pre></td></tr></table></figure></div><p>redis默认路径</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@zst local]# cd bin/</span><br><span class="line">[root@zst bin]# ls</span><br><span class="line">cloud-id        jemalloc-config  jsondiff     jsonschema        luajit-2.0.4  normalizer       redis-check-rdb  redis-server</span><br><span class="line">cloud-init      jemalloc.sh      jsonpatch    libmcrypt-config  mcrypt        redis-benchmark  redis-cli</span><br><span class="line">cloud-init-per  jeprof           jsonpointer  luajit            mdecrypt      redis-check-aof  redis-sentinel</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>4、将redis配置文件，复制到我们当前目录下</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231107000634262.png" alt="image-20231107000634262"></p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@zst bin]# cp /usr/local/redis/redis-stable/redis.conf zconf</span><br><span class="line">[root@zst bin]# ls</span><br><span class="line">cloud-id        jemalloc-config  jsondiff     jsonschema        luajit-2.0.4  normalizer       redis-check-rdb  redis-server</span><br><span class="line">cloud-init      jemalloc.sh      jsonpatch    libmcrypt-config  mcrypt        redis-benchmark  redis-cli        zconf</span><br><span class="line">cloud-init-per  jeprof           jsonpointer  luajit            mdecrypt      redis-check-aof  redis-sentinel</span><br><span class="line">[root@zst bin]# cd zconf/</span><br><span class="line">[root@zst zconf]# ls</span><br><span class="line">redis.conf</span><br><span class="line">[root@zst zconf]# </span><br></pre></td></tr></table></figure></div><p>5、redis默认不是后台启动的，修改配置文件！</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@zst zconf]# vim redis.conf </span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231107000934388.png" alt="image-20231107000934388"></p><p>6、启动redis服务</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231107001124702.png" alt="1"></p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认是本机所以就不加 -h</span></span><br><span class="line"></span><br><span class="line">[root@zst bin]# redis-cli -p 6379 # 使用redis客户端连接</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; set name zst</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;zst&quot;</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>7、查看redis进程是否开启</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@zst ~]# ps -ef | grep redis</span><br><span class="line">root      1055     1  0 00:11 ?        00:00:00 redis-server 127.0.0.1:6379</span><br><span class="line">root      1128 26800  0 00:12 pts/0    00:00:00 redis-cli -p 6379</span><br><span class="line">root      1306  1250  0 00:14 pts/2    00:00:00 grep --color=auto redis</span><br><span class="line">[root@zst ~]# </span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>8、关闭redis服务</p><p>先关闭，后退出</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231107001628363.png" alt="image-20231107001628363"></p><p><strong>之后使用单机多redis服务</strong></p><h3 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h3><p>redis-benchmark 是一个压力测试工具（官方自带）</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@zst bin]# redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数可从菜鸟查看</span></span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231107211030644.png" alt="image-20231107211030644"></p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>默认16个数据库</p><p>默认使用第0个</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231107211218967.png" alt="image-20231107211218967"></p><p>使用select 切换</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@zst bin]# redis-cli </span><br><span class="line">127.0.0.1:6379&gt; select 3 # 切换</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; DBSIZE # 大小</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379[3]&gt; set name zst</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; DBSIZE</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379[3]&gt; set name zst</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; DBSIZE</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; get name</span><br><span class="line">&quot;zst&quot;</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">127.0.0.1:6379[3]&gt; flush db</span><br><span class="line">(error) ERR unknown command &#x27;flush&#x27;, with args beginning with: &#x27;db&#x27; </span><br><span class="line">127.0.0.1:6379[3]&gt; flushdb # 刷新数据库，单个</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379[3]&gt; flushAll # 全部刷新（也就是清除）</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><blockquote><p>redis 是单线程的！</p></blockquote><p>redis非常快，是基于内存的，所以cpu不是其性能瓶颈，redis瓶颈是其内存和网络，所以不必使用多线程，直接就用单线程了</p><p><strong>redis为什么快</strong>？</p><p>redis是将所有数据放到内存中，所以使用单线程就是快，使用多线程会产生上下文切换来切换cpu，会耗时，对于内存来说如果没有上下文切换，效率就是最快的！</p><h2 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h2><h3 id="Redis-key"><a href="#Redis-key" class="headerlink" title="Redis-key"></a>Redis-key</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists name # 判断是否存在</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; exists age</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; move name 1 # 将name从当前数据库移动到1数据库</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">127.0.0.1:6379&gt; keys * # 获取所有建</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">127.0.0.1:6379&gt; set name zst</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;zst&quot;</span><br><span class="line">127.0.0.1:6379&gt; expire name 10s=</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br><span class="line">127.0.0.1:6379&gt; expire name 10 # 设置key过期时间</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;ttl&#x27; command</span><br><span class="line">127.0.0.1:6379&gt; ttl name ## 查看key还有多少时间</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(integer) -2</span><br><span class="line">127.0.0.1:6379&gt; keys *&#x27;=</span><br><span class="line">Invalid argument(s)</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; del name  # 删除键</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; type name # 查看类型</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; type age</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3> <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 k</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; append key1 &quot;hello&quot;  # 追加</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;khello&quot;</span><br><span class="line">127.0.0.1:6379&gt; strlen key1 # 获得长度</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; append key1 &quot;zst&quot;</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;khellozst&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; append name &quot;zst&quot; # 键不存在，即set</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get name </span><br><span class="line">&quot;zst&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash"><span class="comment">########################################################</span></span></span><br><span class="line"> </span><br><span class="line">127.0.0.1:6379&gt; set views 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;0&quot;</span><br><span class="line">127.0.0.1:6379&gt; incr views # 自动 + 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; incr views</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; decr views # 自动 - 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; incrby views 10 # 自动加你想要的数</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;11&quot;</span><br><span class="line">127.0.0.1:6379&gt; decrby views 5 # 自动 - n</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;6&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">范围 range 闭区间</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; getrange key1  0 3</span><br><span class="line">&quot;hell&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange key1 0 -1 # 获取全部</span><br><span class="line">&quot;hello,zst&quot;</span><br><span class="line">127.0.0.1:6379&gt; setrange key2 1 xx # 替换指定位置开始的字符串</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line">&quot;axxkedff&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; setex key3 30 hello  # 设置值并指定过期时间 set with expire</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(integer) 25</span><br><span class="line">127.0.0.1:6379&gt; get key3</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; setnx mykey &quot;hello&quot;  # 如果key不存在就设置 set if not exists</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get mykey</span><br><span class="line">&quot;hello&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######################################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;k1&quot;</span><br><span class="line">2) &quot;k3&quot;</span><br><span class="line">3) &quot;k2&quot;</span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">127.0.0.1:6379&gt; msetnx k4 v4 k5 v5  # 原子性操作 msetnx</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####################################################</span></span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对象  两种设置方法</span></span><br><span class="line">127.0.0.1:6379&gt; set user:1 &#123;name:zst,age:18&#125;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get user:1</span><br><span class="line">&quot;&#123;name:zst,age:18&#125;&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; mset user:2:name zhangsan user:2:age 11 </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get user:2</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; mget user:2:name user:2:age</span><br><span class="line">1) &quot;zhangsan</span><br><span class="line">2) &quot;11&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###############################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">getset 先拿到值，之后再设置值</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; getset db redis # 不存在返回nil，再设置</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; getset db mongodb # 如果存在先获得，再改变</span><br><span class="line">&quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line">&quot;mongodb&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>string 中的value除了是字符串还可以是数字</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>列表</p><p>所有命令以l开头，除了push和pop，看下面</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list one # 从前后往后放</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush list two</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush list three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpush list four # 从后往前放</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1 # 查看</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">4) &quot;four&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#########################################################</span></span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lpop list  # 从前移</span><br><span class="line">&quot;three&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop list # 从后</span><br><span class="line">&quot;four&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#############################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 0 # 通过下标获取</span><br><span class="line">&quot;two&quot;</span><br><span class="line">127.0.0.1:6379&gt; lindex list 1</span><br><span class="line">&quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">########################</span></span></span><br><span class="line">127.0.0.1:6379&gt; llen list</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除指定值</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 three # 可以有重复值，指定移除多少个</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;one&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">trim 把指定位置截取下来</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpush list three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lpush list four</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; ltrim list 1 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################</span></span></span><br><span class="line">rpoplpush list1 list2  # 弹出来，加进去</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等等等。。。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###############</span></span></span><br><span class="line">lset </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将列表指定下标的值替换为另一个 不存在，报错</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###########</span></span></span><br><span class="line">linsert list # 插入指定值的前面/后面</span><br></pre></td></tr></table></figure></div><p><strong>即可以作为栈，也可以作为队列</strong></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>无序、不重复</p><p>都是以 s开头</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset zst # 添加</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset zst</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; sadd myset hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset world</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset # 查看成员</span><br><span class="line">1) &quot;zst&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">3) &quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt; sismember  myset zst # 判断是否存在</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################</span></span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; scard myset # 获取个数</span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#########################</span></span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; srem myset hello # 移除</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;zst&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################</span></span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset # 随机获取</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line">&quot;world&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################</span></span></span><br><span class="line">127.0.0.1:6379&gt; spop myset # 随机弹出</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;zst&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#############</span></span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd myset2 you</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smove myset myset2 zst # 转移</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;world&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) &quot;you&quot;</span><br><span class="line">2) &quot;zst&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####################</span></span></span><br><span class="line"></span><br><span class="line">sdiff # 差集</span><br><span class="line">sinter # 交集</span><br><span class="line">sunion # 并集</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>都是以h开头</p><p>map集合；跟字符串差不多，只是这里变成了key value集合</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hset myhash a zst</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;hget&#x27; command</span><br><span class="line">127.0.0.1:6379&gt; hget myhash a</span><br><span class="line">&quot;zst&quot;</span><br><span class="line">127.0.0.1:6379&gt; hmset myhash b hello c world # 批量</span><br><span class="line">OK </span><br><span class="line">127.0.0.1:6379&gt; hmget myhash b c # 批量</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt; hgetall</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;hgetall&#x27; command</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;zst&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;hello&quot;</span><br><span class="line">5) &quot;c&quot;</span><br><span class="line">6) &quot;world&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#############</span></span></span><br><span class="line">127.0.0.1:6379&gt; hdel myhash c # 删除</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;zst&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;hello&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###############</span></span></span><br><span class="line">127.0.0.1:6379&gt; hlen myhash  # 获取多少个值</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hexists myhash a # 判断指定key是否存在</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取所有key和value</span></span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;zst&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#############################</span></span></span><br><span class="line">incrby decrby 指定自增自减；这里自减先使用 incrby -1；decrby 好像有问题</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash d 1</span><br><span class="line">(integer) 6</span><br><span class="line"> </span><br><span class="line"> 127.0.0.1:6379&gt; hincrby myhash d -1</span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##############</span></span></span><br><span class="line">也可以有对象</span><br><span class="line">127.0.0.1:6379&gt; hset use:1 name zst</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget use:1 name</span><br><span class="line">&quot;zst&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset(有序集合)"></a>Zset(有序集合)</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">中间的参数就是其优先级</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 a 2 b 3 c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange myset 0 -1</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从小到达排序</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore myset -inf +inf</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">后面可以是自己本身的结果</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore myset -inf 2</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">携带value</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore myset -inf 2 withscores</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">倒序，别的和正序一样</span></span><br><span class="line">127.0.0.1:6379&gt; zrevrangebyscore myset +inf -inf</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除</span></span><br><span class="line">127.0.0.1:6379&gt; zrem myset c</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange myset 0 -1</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下俩个都是计数；后者有区间</span></span><br><span class="line">127.0.0.1:6379&gt; zcard myset</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zcount myset -inf +inf</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><ul><li>geospatial   地理位置 geo 开头</li><li>Hyperloglog  基数统计 和set一样也可以去重，但是所需内存是固定，占内存非常小；但使用这个是需要容错的 pf开头</li><li>Bitmap   位存储  用来存储二进制 0 1；一个事务只有两个状态就可以使用这个 b开头</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>一组命令集合，所有命令都会被序列化，在事务执行过程中按照顺序执行；一次性、顺序性、排他性！</p><p>Redis 单条命令是保证原子性的，但Redis事务不保证原子性的;没有隔离级别；</p><p>1、开启事务（multi）</p><p>2、命令入队 （就是命令）</p><p>3、执行事务 （exec）</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi  # 开启事务</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一系列命令入队</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; set k1 v1 </span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set k2 v2 </span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; exec # 执行事务</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">4) OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379(TX)&gt; discard # 放弃事务；那这一切命令都不会被执行</span><br></pre></td></tr></table></figure></div><blockquote><p>编译型异常（代码有问题，命令错误），事务中所有命名都不会被执行</p></blockquote><blockquote><p>运行时异常（1&#x2F;0），其他命令可以正常执行，错误命令抛出异常</p></blockquote><p><strong>Redis实现乐观锁</strong></p><p>监控！watch</p><ul><li>获取version</li><li>更新时候比较version</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set out 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money # 监控money对象</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; exec # 事务正常结束，期间没有发生任何问题</span><br><span class="line">1) (integer) 80</span><br><span class="line">2) (integer) 40</span><br></pre></td></tr></table></figure></div><ul><li>再开一个客户端</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用watch监控， 第一个客户端事务还没提交时，另一个客户端修改了money，则提交事务时出错</span></span><br><span class="line">127.0.0.1:6379&gt; WATCH money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; INCRBY money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC # 此之前另一个客户端修改值</span><br><span class="line">(nil)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">之后重新进行事务的，先进行unwatch解锁</span></span><br><span class="line">127.0.0.1:6379&gt; unwatch</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; DECRBY money 100</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; exec</span><br><span class="line">1) (integer) 900</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>如果发现事务执行失败，先解锁，之后再重新watch进行事务</p><p>秒杀系统就是根据这个</p><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>使用Java来操作Redis</p><ul><li>导入依赖</li></ul><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;4.2.3&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!-- https://mvnrepository.com/artifact/com.alibaba.fastjson2/fastjson2 --&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;fastjson2&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;2.0.40&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>编码测试<ul><li>连接数据库</li><li>编写命令</li><li>关闭连接</li></ul></li></ul><h2 id="SpringBoot-整合Redis"><a href="#SpringBoot-整合Redis" class="headerlink" title="SpringBoot 整合Redis"></a>SpringBoot 整合Redis</h2><ul><li>配置redis的配置类</li><li>创建起步工具时选择redis</li></ul><p>jedis被替换为了lettuce</p><p>jedis：采用的直连，多个线程操作的话是不安全的，如果想要避免不安全，使用jedis pool连接池；BIO</p><p>lettuce：采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况；可以减少线程数量；NIO</p><p>还有一个原因是jedis源码中有些配置没有成功</p><p>Redis使用了默认的JDK序列化，使字符串转义可能，会出现乱码，我们会使用json来序列化</p><h2 id="自定义RedisTemplate"><a href="#自定义RedisTemplate" class="headerlink" title="自定义RedisTemplate"></a>自定义RedisTemplate</h2><p>重新构建redisTemplate，将其放置在配置类中</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231109231023691.png" alt="image-20231109231023691"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231109231055172.png" alt="image-20231109231055172"></p><p>因为Redis使用了默认的JDK序列化，使字符串转义可能，会出现乱码，我们会使用json等等来序列化</p><p>这样我们的类不用实现序列化，这里会序列化</p><p>传到redis中的值也不回乱码</p><p><strong>构建redis工具类RedisUtil，这样就可以直接使用apil，不用再使用redisTemplate.openforXxx</strong></p><h2 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h2><p>通过配置文件启动</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231109231724648.png" alt="image-20231109231724648"></p><p>1、不区分大小写 ； 单位的转换</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231109231854709.png" alt="image-20231109231854709"></p><p>2、可以将其他配置文件包含起来</p><p> 3、 daemonize yes 默认是no这里改为了yes，使后台守护方式运行</p><p>4、 appendonly no 默认不开aof模式，使用rdb方式进行持久化</p><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>redis是一个内存数据库，断电就会丢失，所以持久化是必须的</p><h3 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231110002937444.png" alt="image-20231110002937444"></p><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，他恢复时直接将快照文件读到内存里；</p><p>redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件；整个过程中，主进程是不进行任何io操作的；所以其效率比aof高；所以默认使用rdb</p><p>缺点：最后一次持久化的文件可能会丢失</p><p>rdb保存的文件是dump.rdb；在生产环境中有时候会将这个文件备份</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231110001715386.png" alt="image-20231110001715386"></p><ul><li><p>触发机制</p><ul><li>save的规则满足的情况下，会自动在bin下生成dump.rdb</li><li>执行flushall命令也会</li><li>退出redis也会</li></ul></li><li><p>如何将rdb中的数据恢复！</p><ul><li>将rdb文件放在redis的启动目录下，redis启动时会自动恢复</li><li>查看位置</li></ul><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231110002541398.png" alt="image-20231110002541398"></p></li></ul><p>几乎默认配置就够用了</p><p>优点：</p><ul><li>适合大规模数据恢复</li></ul><p>缺点：</p><ul><li>需要一定的时间间隔操作，如果redis意外宕机了，这最后一次修改的数据就没有了</li><li>fork进程的时候需要内存</li></ul><h3 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h3><p>将我们所有命令记录下来，history，恢复时候就把这个文件全部都再执行一遍</p><p>以日志的形式来记录每个写操作，将Redis执行过得所有指令记录下俩（除了读），只许追加文件，不许改文件，重启redis的话，会根据这个配置文件从前到后执行一遍以完成数据恢复</p><p>保存文件为appendonly.aof</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231110004034114.png" alt="image-20231110004034114"></p><p>默认是不开启的</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231110003954685.png" alt="image-20231110003954685"></p><p>每秒钟写入一次。</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231110003914861.png" alt="image-20231110003914861"></p><p>开启之后生成的文件（bin下）就会根据我们的写操作一秒钟写入一次，如果我们破坏了这个aof文件，将启动不了redis</p><p>可以通过下面这条命令修复</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231110004337711.png" alt="image-20231110004337711"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231110004306455.png" alt="image-20231110004306455"></p><p>但会丢失一些数据</p><p>优点：对应的三种方式</p><ul><li>每一次修改都同步，文件完整性更好！</li><li>每秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率更高</li></ul><p>缺点：</p><ul><li>相对于数据文件来说，aof远大于rdb，修复的速度也比rdb慢</li><li>aof写操作，效率比rdb低</li></ul><p>当我们的aof文件大于了64mb之后。就会rewrite重写，生成新的aof文件</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231110005248652.png" alt="image-20231110005248652"></p><p>当同时开启两个之后，会恢复aof中的数据，完整</p><h2 id="消息订阅"><a href="#消息订阅" class="headerlink" title="消息订阅"></a>消息订阅</h2><p>订阅者订阅了频道</p><p>发布者往频道中发布了信息</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">订阅信息</span></span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE zzbond # 订阅频道，所以我们就在这里监听</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;zzbond&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在另一台机器发布消息</span></span><br><span class="line">127.0.0.1:6379&gt; PUBLISH zzbond hello,zst # 发布信息</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 另外监听的一边就能订阅到</span></span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE zzbond</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;zzbond&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;message&quot; # 消息</span><br><span class="line">2) &quot;zzbond&quot; # 哪个频道</span><br><span class="line">3) &quot;hello,zst&quot; # 具体消息</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><p>数据的复制是单向的，只能从主机复制到从机</p><p>master以写为主，slave以读为主</p><p>80%基本都是读操作，所以将其在从机种进行，减缓服务器压力！</p><p>作用：1、数据冗余：将数据进行备份，是持久化的另一种方式</p><p>2：故障恢复</p><p>3：负载均衡</p><p>4：高可用基石</p><p>主从复制必须要使用的，数据访问量大，单机访问不可能</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>只配置从库，不配置主库</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一台机子查看其默认配置，是主机</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:master # 角色</span><br><span class="line">connected_slaves:0 # 连接从机</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:b9b521447e67bf8089517766ca26d253df0a8ef2</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>复制三个配置文件，然后修改其信息</p><p>1、端口</p><p>2、pid</p><p>3、输出的日志文件名字 logfile</p><p>4、rdb持久化文件的名字 dump</p><p>之后就可以在三个客户端里分别启动不同server 使用不用端口登录，可以看到集群就搭建好了</p><p>通过进程信息查看就可以知道</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231110194954064.png" alt="image-20231110194954064"></p><h3 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h3><p><strong>配置好集群之后，每台主机默认都以自己为主机</strong></p><p>配置：只用去配置从机，认老大！一主（79），二从（80，81）</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379 # 在从机上使用slaveof配置主机，ip 端口</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replaction</span><br><span class="line">127.0.0.1:6380&gt; info replication # 查看信息</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:4</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_read_repl_offset:42</span><br><span class="line">slave_repl_offset:42</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:78eaddc92cbd9a2e1e94b7a6aaaa2ca39542420e</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:42</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:15</span><br><span class="line">repl_backlog_histlen:28</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在主机上就可以看到信息</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=56,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:78eaddc92cbd9a2e1e94b7a6aaaa2ca39542420e</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:56</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:56</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">另外一台也一样</span></span><br></pre></td></tr></table></figure></div><p>这上面使用的是命令，真实的配置是在文件种，这样配来只是暂时的，重新启动之后就会变回主机</p><p>在配置文件中，进行配置，启动之后就是从机</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231110200047535.png" alt="image-20231110200047535"></p><blockquote><p>主机负责写，从机负责读；主机中的信息，会被从机自动保存</p></blockquote><ul><li>全量复制：将主机数据全部复制到自己</li><li>增量复制：将新的所有收集到的数据复制给从机</li></ul><p>当从机断开之后再次连接就是全量复制</p><p>主机断开之后，从机依然连接主机，但还是只能读；主机再次恢复之后，依然是一主二从</p><p>除此之外，还有另一种主从复制</p><blockquote><p>层层链路</p></blockquote><p>81 主机在进行配置时将其端口配置到80，但此时80端口任然是从节点，只能进行读取，不能写入</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231110225845782.png" alt="image-20231110225845782"></p><blockquote><p>如果79断了，之后需要自己手动在配置 slaveof no one ，哪台主机这样之后，他就不是从机了，自己变为了主机，别的机器就可以进行配置</p></blockquote><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><blockquote><p>自动选举老大</p></blockquote><p>1、哨兵配置文件 sentinel.conf</p><p>一般会有多个哨兵，这里只设置了一个</p><blockquote><p> 信息补充：虽然sentinel集群中每个sentinel都互相连接彼此来检查对方的可用性以及互相发送消息。但是你不用在任何一个sentinel配置任何其他的snetinel节点。因为sentinel利用了master的发布&#x2F;订阅机制去自动发现其它监控了统一master的sentinel节点。</p></blockquote><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor  myredis 127.0.0.1 6379 1</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sentinel monitor 监控名称 ip port</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>后面的数字1，代表主机挂了，slave投票，看让谁成为主机；</p><p>2、启动哨兵</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel zconf/sentinel.conf</span><br></pre></td></tr></table></figure></div><p>将6379主机关闭；会自动进行故障专业，投票出另一台slave为master</p><p>当6379回来，会变成从机</p><p>如果想使用高可用那就集群哨兵</p><h2 id="Redis-cluster"><a href="#Redis-cluster" class="headerlink" title="Redis cluster"></a>Redis cluster</h2><p>集群点</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231119214500719.png" alt="image-20231119214500719"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231119215008293.png" alt="image-20231119215008293"></p><p>最少是三主三从，主节点读写，从结点作为备用</p><h2 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a>Redis缓存穿透和雪崩</h2><h3 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231111001207440.png" alt="image-20231111001207440"></p><blockquote><p>概念</p></blockquote><p>当用户 想去查询一个数据，但是缓存中没有，也就是redis中没有，然后现在我们就会去查询MySQL数据库，发现也没有，于是查询失败，当用户很多时，一起去访问数据库，这时候就会导致数据库压力很大，这就是缓存穿透</p><blockquote><p>解决方法</p></blockquote><p>1、布隆过滤器，一种数据结构，对所有可能的查询参数以hash的形式存储，在控制层先进行校验，不符合就丢弃，从而避免了对底层的压力。</p><p><img lazyload src="/images/loading.svg" data-src="/2023/11/06/redis-blog/image-20231111001609317.png" alt="image-20231111001609317"></p><p>2、缓存空对象</p><p>如果没有被命中就在redis中缓存空对象</p><h3 id="缓存击穿（量太大，缓存过期！）"><a href="#缓存击穿（量太大，缓存过期！）" class="headerlink" title="缓存击穿（量太大，缓存过期！）"></a>缓存击穿（量太大，缓存过期！）</h3><p>当高并发的对其中一个点进行访问时，如果此时出现了缓存过期，此时所有的并发量就会对数据库访问，此时就会导致数据库压力很大，而且数据库还要写回缓存</p><blockquote><p>解决方法</p></blockquote><p>1、设置热点数据永不过期</p><p>2、分布式锁，对于同一个key，只有一个线程去查询后端</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>在某一个时间段，缓存过期了，或者redis宕机了</p><p>例如双11时，将一批热点商品放入缓存中，但某时间缓存过期了，这时候就会迎来雪崩</p><p>解决</p><p>1、redis高可用多设置几台redis，集群！！！</p><p>2、限流降级，限制其他服务器的活动来全力完成这个</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis学习&quot;&gt;&lt;a href=&quot;#Redis学习&quot; class=&quot;headerlink&quot; title=&quot;Redis学习&quot;&gt;&lt;/a&gt;Redis学习&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;敬畏之心可以使人进步！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>docker-blog</title>
    <link href="http://example.com/2023/10/31/docker-blog/"/>
    <id>http://example.com/2023/10/31/docker-blog/</id>
    <published>2023-10-31T12:17:52.000Z</published>
    <updated>2023-11-07T16:24:47.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-学习"><a href="#Docker-学习" class="headerlink" title="Docker 学习"></a>Docker 学习</h1><blockquote><p>弱小和无知不是生存得障碍，傲慢才是  —-《三体》</p></blockquote><blockquote><p>只要学不死，就往死里学！！！</p></blockquote><h2 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h2><p>Java —- jar（环境）—– 打包项目带上环境（镜像）—– Docker仓库（商店）—— 别人下载发布得镜像直接运行即可</p><p>思想来自于集装箱！</p><p>核心思想：隔离！</p><p>文档地址：<a class="link" href="https://docs.docker.com/">Docker Docs <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="Docker基本组成"><a href="#Docker基本组成" class="headerlink" title="Docker基本组成"></a>Docker基本组成</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231031211601853.png" alt="image-20231031211601853"></p><p><strong>镜像</strong>（image）：通过镜像创建容器服务（run命令），可以创建多个容器，容器之间相互隔离，最终得服务或者项目是运行在容器之中的</p><p><strong>容器</strong>（container）：基本命令，启动、停止、删除</p><p><strong>仓库</strong>（repository）：存放镜像</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1、购买云服务器</p><p>2、卸载旧docker</p><p>3、安装docker</p><h2 id="Docker原理与命令"><a href="#Docker原理与命令" class="headerlink" title="Docker原理与命令"></a>Docker原理与命令</h2><p>相当于是一个cs架构</p><p>镜像命令</p><ul><li>docker pull  下载镜像</li><li>docker run   运行镜像</li><li>docker rmi -f   [镜像id]  等等  删除镜像</li></ul><p>容器命令</p><p>docker run 【参数】 image  </p><p>–name &#x3D; “name”</p><p>-d   后台方式运行</p><p>-it  以交互式运行，进入容器查看内容    &#x2F;bin&#x2F;bash (后面这个加入到最后，是进入控制台命令)   ； 进入之后容器就是镜像id</p><p>-p  指定容器端口  可以映射主机端口   主机端口：容器端口</p><p>-P  随机端口</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231103100035818.png" alt="image-20231103100035818"></p><p>docker ps 【参数】 查看容器</p><p>退出容器 ： </p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit #容器停止并退出</span><br><span class="line">Ctrl + P + Q # 退出不停止</span><br></pre></td></tr></table></figure></div><p>删除容器</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f 容器id # 不能移除正在运行得容器，加上-f就可以</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231103101741457.png" alt="image-20231103101741457"></p><p>启动容器</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id</span><br><span class="line">restart 重启</span><br><span class="line">stop 关闭</span><br></pre></td></tr></table></figure></div><p>后台启动容器</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d 容器id</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果容器中没有应用，会自动立刻停止</span></span><br></pre></td></tr></table></figure></div><p>进入容器</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec 容器id  /bin/bash # 方式一，进入容器之后会进去一个新的终端，可以进行命令操作</span><br><span class="line"></span><br><span class="line">docker attach 容器id  # 方式二，进入容器里正在执行得终端，不会开启新的终端</span><br></pre></td></tr></table></figure></div><p>日志</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231104004943088.png" alt="image-20231104004943088"></p><p>写一段shell 脚本后台运行，通过日志查看</p><p>查看进程 <strong>pid才是进程号</strong></p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231104005157855.png" alt="image-20231104005157855"></p><p>查看镜像元数据</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231104010214583.png" alt="image-20231104010214583"></p><p>从容器中拷贝文件到虚拟机主机上（反过来是用数据卷挂载）</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231104011436357.png" alt="image-20231104011436357"></p><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><p>部署nginx（–rm 退出容器就删除了容器）</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231104012545957.png" alt="image-20231104012545957"></p><p>通过-p 来暴露Linux的端口让我可以通过这个端口访问到容器内的nginx（默认80端口）</p><p>注意这个端口Linux防火墙是否已开（我好像关闭了防火墙），阿里云服务器安全组是否已开</p><p>进入容器</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231104015320699.png" alt="image-20231104015320699"></p><p><strong>但每次修改配置文件都要进入容器内部，十分麻烦，后面可以在容器外部提供一个映射路径，修改外部容器内部就可以修改了，使用 -v数据卷技术</strong></p><p>有时候我们部署了东西，但访问的时候却发现是404的话，说明docker容器是把这个镜像给最小化了的，但是是访问成功了的，看看其中有没有什么文件有额外的东西，例如tomcat中就有一个webapps.dist存放了文件，讲其复制到webapps下就可以了</p><h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><p>部署elasticsearch</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231104142756930.png" alt="image-20231104142756930"></p><p>因为ES所占内存较大，所以设置Java堆内存，以更快运行ES</p><h3 id="docker-可视化控制面板-portainer"><a href="#docker-可视化控制面板-portainer" class="headerlink" title="docker 可视化控制面板 portainer"></a>docker 可视化控制面板 portainer</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231104142934171.png" alt="image-20231104142934171"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231104143021480.png" alt="image-20231104143021480"></p><h2 id="Docker镜像原理"><a href="#Docker镜像原理" class="headerlink" title="Docker镜像原理"></a>Docker镜像原理</h2><h3 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h3><p>一种轻量级、可独立执行的安装包，用来打包软件运行环境和基于运行环境开发的软件，里面包含了软件的代码，库，环境变量，配置文件等</p><h3 id="镜像加载原理"><a href="#镜像加载原理" class="headerlink" title="镜像加载原理"></a>镜像加载原理</h3><p>联合文件系统（UnionFS）</p><p>docker 安装的centos等等镜像都是打包，压缩过得精简的，只包含基本的命令、目录、文件等，其所用内核还是主机的，因为这些镜像的基本命令、目录等等（rootf）这些可以不同，但内核（bootfs）这些基本是一致的</p><h3 id="分层原理"><a href="#分层原理" class="headerlink" title="分层原理"></a>分层原理</h3><p>docker镜像都是只读的，当我们run之后就加了一层可写层，在镜像的顶部，通常说为容器层，其之下为镜像层</p><h3 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105004812303.png" alt="image-20231105004812303"></p><p>想要保存这个容器的状态，就可以提交镜像，之后直接用</p><h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><p>数据？不能在容器中！！！数据持久化！</p><p>容器之间的数据共享，Docker容器产生的数据，同步到本地</p><p>容器中的目录挂载到Linux的目录上，数据卷技术！</p><h3 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h3><p>数据卷在挂载时没有目录会自己创建</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105005931112.png" alt="image-20231105005931112"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105005949645.png" alt="image-20231105005949645"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105010212151.png" alt="image-20231105010212151"></p><p>挂载完成，之后数据会进行同步！！</p><h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>在进行同步挂载时，可以挂载文件，也可以挂载数据</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105012137285.png" alt="image-20231105012137285"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105012214935.png" alt="image-20231105012214935"></p><p>navicat连接成功</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105012231890.png" alt="image-20231105012231890"></p><p>之后数据都是同步的，当容器删除之后，这里的数据还是在的，然后重新创建容器时同样挂载到这个目录就行了</p><h3 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h3><p>匿名：不指定Linux上的地址</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105013044664.png" alt="image-20231105013044664"></p><p>使用docker volume ls 查看卷挂载 ，这些一长串数字就是挂载的地址</p><p>具名：将 -v后面写Linux路径的地址改为一个名字，这个名字是数据卷的名字，不是地址，因为不是&#x2F;开头</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105013530944.png" alt="image-20231105013530944"></p><p>就可看到卷名了</p><p>可以通过以下命令查看到具名挂载的目录位置</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@zst ~]# docker volume inspect testnginx02</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2023-11-05T01:35:09+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/testnginx02/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;testnginx02&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><p><strong>不建议使用匿名挂载</strong></p><p>如果在容器路径后面加上ro就代表只读权限，容器内部不能修改，只能查看</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@zst _data]# docker run -d -P --name nginx02 -v testnginx02:/etc/nginx:ro nginx</span><br></pre></td></tr></table></figure></div><p>默认是rw</p><h2 id="初始Dockerfile"><a href="#初始Dockerfile" class="headerlink" title="初始Dockerfile"></a>初始Dockerfile</h2><p>用来构建docker镜像的文件！命令脚本</p><p>镜像是一层一层的，所以在镜像中一个命令就是一层</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">建议dockerfile 文件名字就叫Dockerfile</span></span><br><span class="line">[root@zst docker-test-volume]# pwd</span><br><span class="line">/home/docker-test-volume</span><br><span class="line">[root@zst docker-test-volume]# vim dockerfile1</span><br><span class="line">FROM centos</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建镜像的时候就进行卷挂载，这样是匿名挂载，因为这两个只是容器内的目录</span></span><br><span class="line">VOLUME [&quot;volume1&quot;,&quot;volume2&quot;]</span><br><span class="line"></span><br><span class="line">CMD echo &quot;----end----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记住最后要加 .</span></span><br><span class="line">[root@zst docker-test-volume]# docker build -f dockerfile1 -t zst/centos:1.0 .</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105133204340.png" alt="image-20231105133204340"></p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105133504906.png" alt="image-20231105133504906"></p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 90b34f8fea99 # 容器id，就可以看到挂载</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105133858159.png" alt="image-20231105133858159"></p><p><strong>以后这种方式用的很多</strong></p><blockquote><p> 后面的&#x2F;bin&#x2F;bash的作用是表示载入容器后运行bash ,docker中必须要保持一个进程的运行，要不然整个容器启动后就会马上kill itself，<strong>这个&#x2F;bin&#x2F;bash就表示启动容器后启动bash。</strong>bash就是脚本命令</p></blockquote><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>两个容器之间的数据共享</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105134231225.png" alt="image-20231105134231225"></p><p>通过 –volumes-from 实现 这就是容器之间互相共享数据（在volume01和volume02目录中）</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105135314005.png" alt="image-20231105135314005"></p><p><strong>当docker1删了之后不影响别的容器</strong></p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>构建镜像的文件</p><p>1、编写dockerfile文件</p><p>2、docker build 构建</p><p>3、docker run 运行镜像</p><p>4、docker push  发布镜像（DokcerHub、阿里云镜像仓库）</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105141127742.png" alt="image-20231105141127742"></p><p>Dockerfile：构建文件，定义了一切步骤，源代码</p><p>Dockerimages：通过Dockerfile生成的镜像，最终发布和运行的产品，以后就不用jar包，war包了</p><p>Dockercontainres：容器就是镜像运行起来的服务器</p><h3 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM  # 基础镜像</span><br><span class="line">MAINTAINER # 镜像是谁写的，姓名，邮箱</span><br><span class="line">RUN  # docker镜像构建的时候需要运行的命令</span><br><span class="line">ADD  #添加内容，会自动解压</span><br><span class="line">WORKDIR  # 进入镜像的工作目录</span><br><span class="line">VOLUME #卷挂载目录</span><br><span class="line">EXPOSE  # 暴露端口配置  和 -p一样</span><br><span class="line">CMD  #指定这个容器刚开始运行时候要做的命令；只有最后一个生效，如果在run的时候有命令，这个会被替代</span><br><span class="line">ENTRYPOINT #和CMD一样；但不会被替代，可以追加命令</span><br><span class="line">ONBUILD # 当构建一个被继承Dockefile的时候，这时候就会运行ONBUILD的指令</span><br><span class="line">COPY # 类似ADD，将文件拷贝到镜像终</span><br><span class="line">ENV # 构建的时候设置环境变量</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h3><p>FROM scratch 这是一个最基础的镜像</p><p>构建一个centos</p><div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> zst&lt;<span class="number">3028393380</span>@qq.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /bin/bash</span></span><br><span class="line"></span><br><span class="line">[root@zst dockerfile-test] docker build -f  mycentos -t mycentos:<span class="number">1.0</span> .</span><br><span class="line"><span class="comment"># 这里的build之所以要加-f 是因为名字不是Dockerfile，需要加上-f启动，如果是的话就不用加-f了，所以对dockerfile的文件就用Dockefile会自动启动</span></span><br></pre></td></tr></table></figure></div><h3 id="构建tomcat镜像"><a href="#构建tomcat镜像" class="headerlink" title="构建tomcat镜像"></a>构建tomcat镜像</h3><p>1、编写Dockerfile</p><div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> zst&lt;<span class="number">3028393380</span>@qq.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> Readme.txt /usl/local/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> jdk-8u141-linux-x64.tar.gz /usr/local</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> apache-tomcat-9.0.82.tar.gz /usr/local</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/jdk1.<span class="number">8.0</span>_141</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"><span class="keyword">ENV</span> CATALINA_HOME /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">82</span></span><br><span class="line"><span class="keyword">ENV</span> CATALINA_BASE /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">82</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /usr/local/apache-tomcat-9.0.82/bin/startup.sh &amp;&amp; <span class="built_in">tail</span> -F  /usr/local/apache-tomcat-9.0.82/bin/logs/catalina.out</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>2、使用docker build 构建镜像</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t mytomcat .</span><br></pre></td></tr></table></figure></div><p>3、运行镜像</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9090:8080 --name zsttomcat -v /home/zst/build/test:/usr/local/apache-tomcat-9.0.82/webapps/test -v /home/zst/build/test:usr/local/apache-tomcat-9.0.82/logs 镜像id</span><br></pre></td></tr></table></figure></div><p>4、编写webapps下的WEB-INF里的web.xml文件和index.jsp文件</p><p>5、测试成功</p><h3 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h3><p>1、登录</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@zst tomcat]# docker login -u zstyfl</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>2、build时需使用docker tag 修改镜像tag</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@zst tomcat]# docker tag 88e677e3269e zstyfl/diytomcat:1.0 # 需是docker的用户名/...</span><br><span class="line">[root@zst tomcat]# docker images</span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED             SIZE</span><br><span class="line">diytomcat             latest    88e677e3269e   About an hour ago   881MB</span><br><span class="line">zst/diytomcat         1.0       88e677e3269e   About an hour ago   881MB</span><br><span class="line">zstyfl/diytomcat      1.0       88e677e3269e   About an hour ago   881MB</span><br><span class="line">mycentos              1.0       3a11c5c94dbf   2 hours ago         488MB</span><br><span class="line">hello-world           latest    9c7a54a9a43c   6 months ago        13.3kB</span><br><span class="line">nginx                 latest    605c77e624dd   22 months ago       141MB</span><br><span class="line">tomcat                latest    fb5657adc892   22 months ago       680MB</span><br><span class="line">mysql                 8.0       3218b38490ce   22 months ago       516MB</span><br><span class="line">zst/centos            1.0       cff771a3c31e   2 years ago         231MB</span><br><span class="line">centos                latest    5d0da3dc9764   2 years ago         231MB</span><br><span class="line">portainer/portainer   latest    580c0e4e98b0   2 years ago         79.1MB</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>3、发布到docker hub</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@zst tomcat]# docker push zstyfl/diytomcat:1.0</span><br></pre></td></tr></table></figure></div><p>由于太慢，进而转为发布到阿里云</p><p>4、发布到阿里云</p><p>可查看阿里云有提示</p><p>阿里云发布也很慢！！！yue</p><p>5、镜像中的仓库应以要发送的镜像来命名</p><h2 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h2><h3 id="Docker0"><a href="#Docker0" class="headerlink" title="Docker0"></a>Docker0</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105213146225.png" alt="image-20231105213146225"></p><p>三个网络</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105222252517.png" alt="image-20231105222252517"></p><p>下面的eth网docker分配的网络</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@zst ~]# ping 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.038 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.039 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.040 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.042 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 time=0.039 ms</span><br><span class="line">^Z</span><br><span class="line">[1]+  Stopped                 ping 172.17.0.2</span><br><span class="line">[root@zst ~]# </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在Linux主机上能ping通容器内部</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>1、每启动一个容器，docker就会为其分配一个ip，只要安装了docker，就会有一个网卡docker0，桥接模式，使用的技术是veth-pair技术！！</p><p>再次查看主机ip会发现其多了一个网卡，这就是容器的网卡，和容器内部相同是一对的，这里是70，容器内部是71，每启动一个就会成对出现一个</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105223203702.png" alt="image-20231105223203702"></p><blockquote><p>这些一对一对的网卡就是veth-pair技术</p><p>正因为有了这个特性，veth-pair充当了一个桥梁，使主机和容器能够互相ping通</p></blockquote><p>2、因为可以看到docker分配的ip是在同一个网段，两容器之间可以互相ping通</p><p>docker网络模型</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105224112957.png" alt="image-20231105224112957"></p><p>结论：tomcat01和tomcat02有一个公用的路由器（Docker0），</p><p>所有容器在不指定网络的情况下，都是由Docker0来路由的，docker会默认给容器分配一个可用的ip</p><p>Docker使用的Linux的桥接</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105224754052.png" alt="image-20231105224754052"></p><p>Docker中得所有网络接口都是虚拟得 ，因为转发效率高！</p><p>只要删除容器，对于一对网桥就没了</p><h3 id="–link"><a href="#–link" class="headerlink" title="–link"></a>–link</h3><blockquote><p>不用通过网络和地址，直接ping通</p></blockquote><p>在创建容器得时候加上–link就可不用ip就能ping通，但是是单向得</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@zst ~]# docker run -it -P --name tomcat02 --link tomcat01 tomcat</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这样可用2 ping 1，但是不能1 ping 2</span></span><br></pre></td></tr></table></figure></div><p>这里设置了tomcat03 link tomcat02；</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231105230214927.png" alt="image-20231105230214927"></p><p>本质： 可以看出–link就是在tomcat03中加了一个tomcat02得映射，这样就可以直接通过tomcat02得名字ping了</p><p><strong>现在不建议使用</strong></p><p>自定义网络，不适用docker0</p><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><blockquote><p>查看所有网络模式</p></blockquote><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@zst ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">a5090ee1925a   bridge    bridge    local</span><br><span class="line">f11b02ed27bb   host      host      local</span><br><span class="line">679e96cf2d87   none      null      local</span><br><span class="line">[root@zst ~]# </span><br></pre></td></tr></table></figure></div><p>网络模式：</p><ul><li>bridge：桥接（默认）</li><li>none：不配置网络</li><li>host：和主机共享网络</li></ul><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231106182310648.png" alt="image-20231106182310648"></p><blockquote><p>上面这两个命令是相同得</p><p>自定义网络，网段都是192.168，这就是ping通得关键</p></blockquote><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自定义网络</span></span><br><span class="line">[root@zst ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">fd6b64d14004bd8dae6bd868927c99ca71bfe9f184d4914d5a4705d2c1a5afc5</span><br><span class="line">[root@zst ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">a5090ee1925a   bridge    bridge    local</span><br><span class="line">f11b02ed27bb   host      host      local</span><br><span class="line">fd6b64d14004   mynet     bridge    local</span><br><span class="line">679e96cf2d87   none      null      local</span><br><span class="line">[root@zst ~]# </span><br><span class="line">[root@zst ~]# docker network inspect mynet</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;mynet&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;fd6b64d14004bd8dae6bd868927c99ca71bfe9f184d4914d5a4705d2c1a5afc5&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2023-11-06T18:32:33.594120615+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;192.168.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">[root@zst ~]# </span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用自定义得网络创建容器；可以看到自己得网络多出了两个容器</span></span><br><span class="line">[root@zst ~]# docker run -d -P --name tomcat01 --network mynet tomcat</span><br><span class="line">5bf527a6028345a93e574d79e8b7d92bbac2005f56b22da7eabb273e767e3316</span><br><span class="line">[root@zst ~]# docker run -d -P --name tomcat02 --network mynet tomcat</span><br><span class="line">11e7bc9ab2d396c165d9376a3977f0fb137d016a0ea2e7229268ffd9a6a24a18</span><br><span class="line">[root@zst ~]# docker network inspect mynet</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;mynet&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;fd6b64d14004bd8dae6bd868927c99ca71bfe9f184d4914d5a4705d2c1a5afc5&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2023-11-06T18:32:33.594120615+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;192.168.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;11e7bc9ab2d396c165d9376a3977f0fb137d016a0ea2e7229268ffd9a6a24a18&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat02&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;dab2e721ddec31d4f565664e56c56dd93ea8fab9c08b4d4605d48271716baaa4&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;5bf527a6028345a93e574d79e8b7d92bbac2005f56b22da7eabb273e767e3316&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat01&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;5fdb9b03b9b91aae7e2e3136bcdf77b718a2b57b22f50cd7ad6e7f0eb5e7b63f&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">[root@zst ~]# </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这样就可以在两个容器之间互相ping通</span></span><br><span class="line">root@5bf527a60283:/usr/local/tomcat# ping tomcat02</span><br><span class="line">PING tomcat02 (192.168.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.061 ms</span><br><span class="line">64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.053 ms</span><br><span class="line">64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.060 ms</span><br><span class="line">^Z</span><br><span class="line">[1]+  Stopped                 ping tomcat02</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><strong>一些镜像中是没有这些ping命令得，可以在家目录下创建一份sources.list文件，将复制到容器中得对应位置，之后apt-get update ，然后就可以使用apt-get install 各种命令了，暂时还没找到怎么下载yum命令</strong></p><h3 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个容器tomcat03，默认docker0</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将其和mynet相连</span></span><br><span class="line">[root@zst ~]# docker network connect mynet tomcat03</span><br></pre></td></tr></table></figure></div><p>查看network详情就可以看到多了一个容器</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/31/docker-blog/image-20231106185552638.png" alt="image-20231106185552638"></p><p>这就是一个容器两个ip！！！</p><p>结论：想要连接别得网络，就可以使用docket network connet 来进行连通！</p><h2 id="使用Docker部署自己得看点资讯项目"><a href="#使用Docker部署自己得看点资讯项目" class="headerlink" title="使用Docker部署自己得看点资讯项目"></a>使用Docker部署自己得看点资讯项目</h2><p>1、将vue项目打包，将dist文件夹下得文件都复制到springboot项目得static文件夹下</p><p>2、将项目打成jar包，上传到服务器</p><p>3、编写Dockerfile</p><div class="highlight-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> zst&lt;<span class="number">3028393380</span>@qq.com&gt;</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> *.jar /cms.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8989</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/cms.jar&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>4、build镜像</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@zst cmsDocker]# docker build -t cms-server:1.0 .</span><br></pre></td></tr></table></figure></div><p>5、运行容器</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@zst cmsDocker]# docker run -d -p 8988:8989 --name zst-springboot01 cms-server</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加上--restart=always 使容器一直运行</span></span><br><span class="line">[root@zst cmsDocker]# docker run -d -p 8988:8989 --name zst-springboot01 --restart=always cms-server:1.0</span><br><span class="line">a2adf230b2fe455c4e3650b967cb91ed4a879a4a3dd5fe51b773ced49921a9fa</span><br></pre></td></tr></table></figure></div><p>6、发布镜像</p><h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2><p>容器越来越多，不好管理，他们之间的启动顺序，关闭，如果都是一个一个的操作的话太麻烦！！！</p><p>使用DockerCompose对容器进行编排,通过一个docker-compose.yml，来定义一组相关联的容器为一个项目</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker-学习&quot;&gt;&lt;a href=&quot;#Docker-学习&quot; class=&quot;headerlink&quot; title=&quot;Docker 学习&quot;&gt;&lt;/a&gt;Docker 学习&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;弱小和无知不是生存得障碍，傲慢才是  —-《三体》&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java中intern、new String（）会创建几个对象</title>
    <link href="http://example.com/2023/10/19/Java-itern-blog/"/>
    <id>http://example.com/2023/10/19/Java-itern-blog/</id>
    <published>2023-10-19T14:50:38.000Z</published>
    <updated>2023-10-20T11:22:20.495Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近研究了一些关于intern的用法,在这做个笔记</p></blockquote><h1 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h1><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><ul><li><p>jdk1.7及以下存在于永久代_方法区中,jdk1.8以后存在元空间方法区中</p></li><li><p>运行时常量池的包装类<strong>Byte,Short,Integer,Long,Character,Boolean。这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据</strong>,在使用时可以直接使用超过之后就会创建新对象</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   System.out.println(a == b); <span class="comment">// true</span></span><br><span class="line">   <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">   <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">   System.out.println(c == d); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div></li></ul><h2 id="字符串常量池移动"><a href="#字符串常量池移动" class="headerlink" title="字符串常量池移动"></a>字符串常量池移动</h2><ul><li>在JDK1.6及之前，字符串常量池是属于运行时常量池的</li><li>JDK1.7以后，字符串常量池被拿出来放到了堆中</li></ul><h2 id="字符串怎样从堆中移动到字符串常量池"><a href="#字符串怎样从堆中移动到字符串常量池" class="headerlink" title="字符串怎样从堆中移动到字符串常量池"></a>字符串怎样从堆中移动到字符串常量池</h2><ul><li>通过 <strong>String a &#x3D; new String(“hello”)</strong>;这种方式所创建得字符串会现在堆中存储一份，如果字符串常量池中没有，会在其中也创建一份，但最终返回得引用是堆中得引用</li><li>String a &#x3D; “hello” 将会看常量池中是否有这个对象有就返回引用，没有就在堆中创建再返回其引用</li></ul><h2 id="使用intern方法"><a href="#使用intern方法" class="headerlink" title="使用intern方法"></a>使用intern方法</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> a.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;hell0&quot;</span>;</span><br><span class="line">a == c ;<span class="comment">// false;</span></span><br><span class="line">b == c ;<span class="comment">// true;</span></span><br></pre></td></tr></table></figure></div><p>这样会将其在字符串常量池中得引用传给b</p><h2 id="会创建几个对象分析"><a href="#会创建几个对象分析" class="headerlink" title="会创建几个对象分析"></a>会创建几个对象分析</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>); </span><br></pre></td></tr></table></figure></div><p>看其在字符串常量池中有无存在，没有就创建两个、有就只会创建一个；</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) + <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure></div><p>假设字符串常量池中没有存在:</p><p>​将会创建5个对象</p><ul><li>new 会创建两个</li><li>world会创建一个</li><li>加号会创建一个StringBuilder 之后 再toString所以会创建两个</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近研究了一些关于intern的用法,在这做个笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;常量池&quot;&gt;&lt;a href=&quot;#常量池&quot; class=&quot;headerlink&quot; title=&quot;常量池&quot;&gt;&lt;/a&gt;常量池&lt;/h1&gt;&lt;h2 id=&quot;运</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>物联网环境监测系统</title>
    <link href="http://example.com/2023/10/16/first-Java-blog/"/>
    <id>http://example.com/2023/10/16/first-Java-blog/</id>
    <published>2023-10-16T14:34:16.000Z</published>
    <updated>2023-10-21T16:53:57.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先，作为个人第一次写得博客如若不足希望大家能够指出，接下来就开始开心得创作吧</p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p><strong>项目源码地址：<a class="link" href="https://github.com/zst11/Caigou.git">https://github.com/zst11/Caigou.git <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></p><ul><li>这是我第一次写得Java项目所以就没有使用SSM框架和web方面，也是比较可惜，就是单纯了得使用了maven和JDBC以及各种jar包</li><li>本项目是根据物联网技术，通过<strong>传感器</strong>对农棚内农作物得参数变化，例如：光照强度、湿度等，经由网关，发送给数据中心，并进行数据的分析和处理；对于此项目本篇文章就重点描述了客户端数据中心的数据操作之后将数据发给服务端，服务端对数据进行的入库操作，至于拿到了数据该如何分析数据不在本项目的范畴之内</li></ul><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p>在数据中心模块中，收到的数据已经进行了简单的预处理，数据的形式为：</p><blockquote><p>100|101|2|16|1|3|57a491fc02|1|1516413763738</p><p>100|101|2|16|1|3|57a891fc02|1|1516413764761</p><p>100|101|2|16|1|3|57a491fc02|1|1516413765686</p><p>100|101|2|256|1|3|001c03|1|1516413766708</p><p>100|101|2|256|1|3|001c03|1|1516413767731</p><p>100|101|2|16|1|3|57a492d002|1|1516413768756</p><p>100|101|2|1280|1|3|02f801|1|1516413769787</p><p>100|101|2|1280|1|3|02f801|1|1516413770702</p><p>….</p></blockquote><p>一行数据作为一组数据，每个数据使用**|**进行分割，每行数据代表一种数据环境，其分为以下九个小部分：</p><p>1、发送端id</p><p>2、树莓派系统id</p><p>3、实验箱区域模块id(1-8)</p><p>4、模块上传感器地址</p><ul><li>16，表示温度和湿度数据</li><li>256，表示光照强度数据</li><li>1280，表示二氧化碳数据</li></ul><p>5、传感器个数</p><p>6、指令标号</p><p>​如果是3表示需要接受数据，如果是16表示需要发送数据</p><p>7、<strong>环境数据</strong></p><p>8、状态标识</p><p>​默认为1，表示成功</p><p>9、采集时间</p><p>我们并不需要把目光放在这些id上，这不是此项目重点，只是一个标识</p><p><strong>特别注意，关于一行中的第7个数据部分</strong></p><p>这部分是真正的环境数据，但是使用的十六进制表示，需要转换为十进制，分三种情况：</p><ul><li><p>如果当前是温度和湿度的数据，则前两个字节是温度，中间两个字节是湿度，剩余字节不用管</p></li><li><p>如果当前是光照强度的数据，则前两个字节就是数据值，剩余字节不用管</p></li><li><p>如果当前是二氧化碳的数据，则前两个字节就是数据值，剩余字节不用管</p></li></ul><blockquote><p><strong>ps</strong>：一个字节是由2个十六进制表示的；第6个数据不需要关心，因为此项目是接收数据进行分析的</p><p>所以全都是3</p></blockquote><h1 id="模块关系"><a href="#模块关系" class="headerlink" title="模块关系"></a>模块关系</h1><p>总共进行三个模块的切分，分别为公共模块、客户端模块、服务端模块</p><p>公共模块：</p><ul><li>配置模块，负责初始化和配置其他模块（使用dom4j解析xml配置文件）</li><li>日志模块，记录系统得运行情况，并且使用其来替代传统得输出（需要使用log4j记录日志信息）</li><li>备份模块，负责在需要得时候对数据进行备份，并且在需要得时候获得之前备份得数据</li></ul><p>客户端：</p><ul><li>采集模块，负责采集预处理好得文件中得数据</li><li>网络模块，负责连接服务器端，并采集得数据发送过去</li></ul><p>服务端（使用了多线程进行实现）：</p><ul><li>入库模块，负责将数据存入数据库</li><li>网络模块，负责等待客户端得连接，并接收发送得数据</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>1、此项目使用了SVN来进行版本控制</p><img lazyload src="/images/loading.svg" data-src="image-20231017230325405.png" alt="image-20231017230325405" style="zoom:67%;"><p>其中仓库名为env_project，里面有三个部分，分别为：</p><ul><li>trunk：项目主干，进行分支得合并</li><li>trg：标签，记录比较重要得版本</li><li>branches：分支，不同用户可以进行分支拉取进行读取</li></ul><p>2、使用maven进行项目构建</p><p><img lazyload src="/images/loading.svg" data-src="/2023/10/16/first-Java-blog/image-20231018214238254.png" alt="image-20231018214238254"></p><p>其中得ui模块为自己想要看得一个临时界面使用GUI进行简单搭建</p><h2 id="项目编写"><a href="#项目编写" class="headerlink" title="项目编写"></a>项目编写</h2><h3 id="采集模块"><a href="#采集模块" class="headerlink" title="采集模块"></a>采集模块</h3><p>新建GatherImpl 来实现common模块中得Gather接口</p><p>实现逻辑：</p><ul><li><p>暂时先使用<strong>缓冲流</strong>来读取文件中得数据，之后在使用备份模块之后使用<strong>随机流</strong>进行读取</p></li><li><p>读取到得数据使用 “|”进行分割，用Environment集合进行接收</p></li><li><p>对于接收到得数据进行数据格式得转换，之后根据<strong>环境数据</strong>来进行<strong>name</strong>得判断、温湿度得切分</p></li><li><p>根据第四行得数据判断此行数据属于什么类别</p></li><li><p>将环境数据进行转换得<strong>公式</strong></p><ul><li><p>v1代表数据的前两个字节（0，4）16进制转10进制的int值，v2代表数据的中间两个字节（4，8）16进制转10</p><p>进制的int值</p></li><li><p>温度：(float)(v1 * 0.00268127-46.85)；湿度：(float)(v2*0.00190735-6)</p></li><li><p>⼆氧化碳浓度和光照强度直接是前两个字节的16进制转10进制即可</p></li></ul></li></ul><p><strong>ps</strong>：如果判断出这行数据属于温湿度得类别，那这条数据就需要被拆成两条</p><h3 id="网络模块（TCP）"><a href="#网络模块（TCP）" class="headerlink" title="网络模块（TCP）"></a>网络模块（TCP）</h3><p>1、客户端</p><p>​将采集得到得数据发送给客户端</p><ul><li>获得服务器ip和端口</li><li>调用对象输出流将数据发送到socket中，记住需实现序列化接口</li><li>调用writeObejct</li></ul><p>2、服务端</p><p>​接收客户端发送得数据</p><ul><li><p>使用多线程编写</p></li><li><p>调用readObject获得object类型得数据</p></li><li><p>将数据安全转换为list</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ins = socket.getInputStream();</span><br><span class="line">ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(ins);</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">Collection&lt;Environment&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// LinkedList ?</span></span><br><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection&lt;?&gt;)&#123;</span><br><span class="line">    Collection&lt;?&gt; l = (Collection&lt;?&gt;) object;</span><br><span class="line">    <span class="keyword">for</span> (Object o:l)&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Environment)&#123;</span><br><span class="line">            list.add((Environment) o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="入库模块"><a href="#入库模块" class="headerlink" title="入库模块"></a>入库模块</h3><p>1、准备工作</p><ul><li><p>因为接收到得数据是一个月中每一天信息，所以我们可以在Navicat中使用存储过程建立31张表，实现如下（MySQL表是</p><p>存储在虚拟机中得）</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">create database envir;</span><br><span class="line">create user &#x27;envir&#x27;@&#x27;%&#x27; identified by &#x27;envir&#x27;;</span><br><span class="line">grant all on envir.* to &#x27;envir&#x27;@&#x27;%&#x27;;</span><br><span class="line">-- set names utf8;</span><br><span class="line">use envir;</span><br><span class="line">-- 使用存储过程建表</span><br><span class="line">DROP PROCEDURE IF EXISTS create_table_do;</span><br><span class="line">delimiter //</span><br><span class="line">CREATE PROCEDURE create_table_do()</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 1;</span><br><span class="line">WHILE i &lt; 32 DO</span><br><span class="line">SET @STMT = CONCAT(&quot;DROP TABLE IF EXISTS `env_detail_&quot;,i,&quot;`;&quot;);</span><br><span class="line">PREPARE STMT FROM @STMT; </span><br><span class="line">EXECUTE STMT;</span><br><span class="line">SET @STMT = CONCAT(&quot;CREATE TABLE IF NOT EXISTS `env_detail_&quot;,i,</span><br><span class="line">&quot;`(`name` varchar(20) NOT NULL COMMENT &#x27;传感器名称&#x27;,</span><br><span class="line">`srcId` varchar(5) NOT NULL COMMENT &#x27;发送端id&#x27;,</span><br><span class="line">`desId` varchar(5) NOT NULL COMMENT &#x27;树莓派系统id&#x27;,</span><br><span class="line">`devId` char(1) NOT NULL COMMENT &#x27;实验箱区域模块id&#x27;,</span><br><span class="line">`sensorAddress` varchar(7) NOT NULL COMMENT &#x27;模块上传感器地址&#x27;,</span><br><span class="line">`count` int(2) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;传感器个数&#x27;,</span><br><span class="line">`cmd`  varchar(5) NOT NULL  DEFAULT &#x27;3&#x27; COMMENT &#x27;指令标号(3表示需要接受数据  16表示需要发送数据)&#x27;,</span><br><span class="line">`status` int(2) NOT NULL DEFAULT &#x27;1&#x27;  COMMENT &#x27;状态标示(默认为1表示成功)&#x27;,</span><br><span class="line">`data` float(9,4) NOT NULL COMMENT &#x27;采集的数据&#x27;,</span><br><span class="line">`gather_date` timestamp NOT NULL COMMENT &#x27;采集时间&#x27;)ENGINE=InnoDB  DEFAULT CHARSET=utf8 COMMENT=&#x27;数据详情日表&#x27;;&quot;</span><br><span class="line">);</span><br><span class="line">PREPARE STMT FROM @STMT; </span><br><span class="line">EXECUTE STMT;</span><br><span class="line">    SET i = i + 1;</span><br><span class="line">END WHILE;</span><br><span class="line">END//</span><br><span class="line">CALL create_table_do();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li><li><p>JDBC的实现封装封装了工具类在util下，在Java与数据库连接时使用数据库连接池Druid</p></li></ul><p>2、实现逻辑</p><ul><li><p>遍历从客户端拿到的集合</p></li><li><p>处理集合中的gatherDate，因为其是TimeStamp类型，使用Calender类获取到天数，根据天数插入到不同的表中</p></li><li><p>使用prepareStatement预处理</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;insert into env_detail_&quot;+day+&quot; values(?,?,?,?,?,?,?,?,?,?)&quot;;</span><br></pre></td></tr></table></figure></div></li><li><p>在使用这种方式创建对象时进行优化只有当天数发生改变时才创建新的pst</p></li><li><p>使用批处理得方式进行提交</p></li></ul><h3 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h3><p>使用日志输出来替代System输出</p><p>1、日志的作用</p><ul><li>日志有不同的等级，可以做出不同的响应</li><li>日志可以输出到文件夹以方便我们查看错误信息</li></ul><p>2、实现逻辑</p><ul><li><p>对log4j的配置文件进行完成（具体log4j怎样使用可以自行百度）</p></li><li><p>定义log接口，实现log接口，实现方法是直接掉API进行实现</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String msg)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String msg)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">warn</span><span class="params">(String msg)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(String msg)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fatal</span><span class="params">(String msg)</span>;</span><br></pre></td></tr></table></figure></div></li><li><p>将原先使用System输出的位置改为日志输出</p></li></ul><h3 id="配置模块"><a href="#配置模块" class="headerlink" title="配置模块"></a>配置模块</h3><p>首先我们需先了解配置模块得作用：</p><p>1、通过配置模块产生其他模块对象，就不用模块中再持有各自实例，将项目进行解耦</p><p>2、当我们需要从配置文件中获取到需要得信息时，可以直接使用配置模块获得</p><p>实现过程：</p><p>1、在实现之前我们先来了解一个概念，回调（callback）</p><p>回调就是我们并不知道此处具体要实现什么，然后正常进行调用，然后当我们各自具体项目实现这个方法时对其各自实现</p><p>此次项目中就定义了两个接口用来定义回调函数</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于实现某个模块需要另一个模块得支持时，创建该模块</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConfigurationAware</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可通过参数configuration的getXxx()方法获取需要的模块的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configuration Configuration接口的实现类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setConfiguration</span><span class="params">(Configuration configuration)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于实现我们在需要到配置文件中得信息时，通过重写init从properties中拿到信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PropertiesAware</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对当前模块进行初始化赋值，变量值从properties中获取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> properties 存储了配置信息(例如ip、端口号)的Properties对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>2、创建Configuration配置接口并实现（ConfigurationImpl）他</p><p>​接口中有实现各个模块得抽象方法</p><p>3、ConfigurationImpl的实现</p><ul><li><p>创建map对象来接收key 标签名 value 权限类名，然后就可以在重写的抽象方法中通过map.get()来获取到不同模块</p></li><li><p>创建properties对象来接收配置信息</p></li><li><p>使用dom4j通过SAXReader来对xml文件进行解析</p></li><li><p>对于解析到elements，对于其是模块名还是配置信息将其放到map或者properties中</p></li><li><p>最后，判断不同的类是否实现了PropertiesAware或者ConfigurationAware接口来进行相应的回调；判断接口是否实现了二者使用instanceof进行判断（instanceof 可以判断类 和 接口）</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((k,v)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (v <span class="keyword">instanceof</span> PropertiesAware)&#123;</span><br><span class="line">                <span class="type">PropertiesAware</span> <span class="variable">p</span> <span class="operator">=</span> (PropertiesAware) v;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    p.init(properties);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v <span class="keyword">instanceof</span> ConfigurationAware)&#123;</span><br><span class="line">                <span class="type">ConfigurationAware</span> <span class="variable">c</span> <span class="operator">=</span> (ConfigurationAware) v;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.setConfiguration(<span class="built_in">this</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="备份模块"><a href="#备份模块" class="headerlink" title="备份模块"></a>备份模块</h3><p>备份模块最初在此项目设计的时候是并不存在得，而之所以在后来设计这一模块是为了对项目整体做出一个优化，使其可以不用读取重复得数据</p><p>实现过程：</p><ul><li><p>创建Backup接口，其中有两个抽象方法</p><ul><li>load（）：调用load可以实现读取到上一次所备份得数据</li><li>store（）：使用store可以将最新得数据进行备份</li></ul><blockquote><p><strong>ps</strong>:我们所备份或者读取到得其实是最后指针所指到得位置</p></blockquote></li><li><p>使用备份模块，获取到上一次备份的数据也就是指针位置和新数据的指针位置进行对比，如若指针位置增加了我们就行数据的采集</p></li><li><p>我们在使用到备份模块之后，就会将数据流的读取方式从缓冲流改变到随机流，这样我们在得到指针位置改变了，就使用随机流中的seek（）方法跳转到上一次备份数据指针的位置，直接从这位置进行数据的采集</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>作为自己的第一个Java项目，但是也不能称之为项目吧，然后一个人完成了这些也觉得挺不错得，接下来就让我们期待下面的项目吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;首先，作为个人第一次写得博客如若不足希望大家能够指出，接下来就开始开心得创作吧&lt;/p&gt;
&lt;h1 id=&quot;项目介绍&quot;&gt;&lt;a href=&quot;#项目</summary>
      
    
    
    
    
    <category term="Java_Project01" scheme="http://example.com/tags/Java-Project01/"/>
    
  </entry>
  
</feed>
